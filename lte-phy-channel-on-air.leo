<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
<?xml-stylesheet ekr_test?>
<leo_file xmlns:leo="http://www.leo-editor.org/2011/leo" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="michael.20120223085633.1280" a="E"><vh>lte-phy-channel-on-air</vh>
<v t="michael.20120305092148.1276" a="E"><vh>3GPP</vh>
<v t="michael.20120305092148.1277" a="E"><vh>36.211</vh>
<v t="michael.20120305092148.1295" a="E"><vh>6 Downlink</vh>
<v t="michael.20120305092148.1304"><vh>5.07.2 Preamble seq gen</vh></v>
<v t="michael.20120305092148.1278"><vh>6.02.4 REGs</vh></v>
<v t="michael.20120305092148.1290"><vh>6.09 PHICH</vh></v>
<v t="michael.20120305092148.1280"><vh>6.10 RS</vh>
<v t="michael.20120305092148.1281" a="E"><vh>6.10.1 CSRS</vh>
<v t="michael.20120305092148.1285"><vh>6.10.1.1 Seq gen</vh></v>
<v t="michael.20120305092148.1279"><vh>6.10.1.2 Mapping to REs</vh></v>
</v>
</v>
<v t="michael.20120305092148.1301" a="E"><vh>6.11 Sync signals</vh>
<v t="michael.20120305092148.1302"><vh>6.11.1 PSS</vh>
<v t="michael.20120305092148.1303"><vh>6.11.1.1 seq gen</vh></v>
<v t="michael.20120305092148.1305"><vh>6.11.1.2 mapping to REs</vh></v>
</v>
<v t="michael.20120312091134.1403" a="E"><vh>6.11.2 SSS</vh>
<v t="michael.20120312091134.1404"><vh>6.11.2.1 Sequence generation</vh></v>
<v t="Michael.20120314113327.1416"><vh>6.11.2.2 Mapping to REs</vh></v>
</v>
</v>
<v t="michael.20120305092148.1293"><vh>6.12 OFDM baseband signal gen</vh></v>
<v t="michael.20120305092148.1296"><vh>6.13 Modulation&amp;upconversion</vh></v>
</v>
<v t="michael.20120305092148.1294"><vh>7 Generic functions</vh>
<v t="michael.20120305092148.1283"><vh>7.2 Pseudo-random seq gen</vh></v>
</v>
</v>
<v t="michael.20120305092148.1315"><vh>Gegeral math</vh>
<v t="michael.20120305092148.1316"><vh>Zadoff-Chu seq</vh></v>
</v>
</v>
<v t="michael.20120305092148.1291"><vh>Plotting_scripts</vh>
<v t="michael.20120305092148.1292"><vh>plot_symbols</vh></v>
</v>
<v t="michael.20120305092148.1306" a="E"><vh>Simulations</vh>
<v t="michael.20120309091906.1376"><vh>Low pass filter</vh>
<v t="michael.20120309091906.1377"><vh>souce code</vh></v>
<v t="michael.20120309091906.1378"><vh>@thin ./test_files/low_pass_filter.py</vh></v>
</v>
<v t="michael.20120305092148.1307"><vh>OFDM depiction</vh>
<v t="michael.20120305092148.1308"><vh>source_code</vh>
<v t="michael.20120305092148.1310" a="E"><vh>General OFDM</vh>
<v t="michael.20120305092148.1293"></v>
<v t="michael.20120305092148.1296"></v>
<v t="michael.20120305092148.1292"></v>
</v>
</v>
</v>
<v t="michael.20120309091906.1388"><vh>Plot methods</vh></v>
<v t="michael.20120305092148.1317" a="E"><vh>PSS gen &amp; detect</vh>
<v t="michael.20120305092148.1319"
expanded="michael.20120305092148.1318,"><vh>@thin ./Simulation/PSS/PSS_gen_detect.py</vh></v>
<v t="michael.20120305092148.1318" a="E"><vh>source code</vh>
<v t="michael.20120305092148.1322"><vh>01. PSS spectrum before OFDM generation</vh></v>
<v t="michael.20120305092148.1320"><vh>02. PSS correlation in freq domain before OFDM gen</vh></v>
<v t="michael.20120305092148.1321"><vh>03. PSS baseband IQ signal in time domain</vh></v>
<v t="michael.20120310203114.1395"><vh>04. PSS baseband IQ spectrum</vh></v>
<v t="michael.20120312091134.1399"><vh>05. PSS baseband IQ spectrum correlation</vh></v>
<v t="michael.20120305092148.1323"><vh>06. PSS Uu signal</vh></v>
<v t="michael.20120309091906.1387"><vh>07. PSS Uu signal downconversion</vh></v>
<v t="michael.20120312091134.1401"><vh>08. PSS Uu signal downconverted correlation</vh></v>
<v t="michael.20120310203114.1394"><vh>09. PSS received IQ spectrum</vh></v>
<v t="michael.20120305092148.1326"><vh>10. PSS Uu signal downconverted decimated to 1/16 correlation</vh></v>
<v t="michael.20120312091134.1402"><vh>11. PSS detect</vh></v>
<v t="michael.20120305092148.1303"></v>
<v t="michael.20120305092148.1305"></v>
<v t="michael.20120305092148.1293"></v>
<v t="michael.20120305092148.1296"></v>
<v t="michael.20120305092148.1292"></v>
<v t="michael.20120305092148.1330"><vh>test</vh></v>
<v t="michael.20120312091134.1398"><vh>Trash Can</vh>
<v t="michael.20120305092148.1327"><vh>08. PSS received IQ FFT</vh></v>
<v t="michael.20120312091134.1400"><vh>09. PSS received IQ time-domain correlation</vh></v>
<v t="michael.20120305092148.1329"><vh>10. PSS Uu signal FFT N/16-point correlation</vh></v>
<v t="michael.20120305092148.1328"><vh>09. PSS received IQ FFT N-point correlation</vh></v>
<v t="michael.20120309091906.1380"><vh>12. PSS Uu signal FFT after 10MHz lowpass N-point correlation</vh></v>
<v t="michael.20120309091906.1384"><vh>15. PSS Uu signal FFT after 540KHz lowpass N-point correlation</vh></v>
<v t="michael.20120309091906.1382"><vh>14. PSS Uu signal FFT after 540KHz lowpass filter</vh></v>
<v t="michael.20120309091906.1381"><vh>13. PSS Uu signal FFT after 10MHz lowpass N/16-point correlation</vh></v>
<v t="michael.20120309091906.1386"><vh>16. PSS Uu signal FFT after 540KHz lowpass N/16-point correlation</vh></v>
<v t="michael.20120309091906.1379"><vh>11. PSS Uu signal FFT after 10MHz lowpass filter</vh></v>
<v t="michael.20120305092148.1325"><vh>09. PSS received IQ decimated to 1/16</vh></v>
<v t="michael.20120305092148.1324"><vh>09. PSS received IQ spectrum correlation</vh></v>
</v>
<v t="michael.20120305092148.1331"><vh>z_fft_of_ZC</vh>
<v t="michael.20120305092148.1316"></v>
</v>
</v>
</v>
<v t="Michael.20120314113327.1412" a="E"><vh>SSS gen &amp; detect</vh>
<v t="Michael.20120314113327.1413" a="E"><vh>source</vh>
<v t="Michael.20120314113327.1415"><vh>01. SSS sequence generation</vh></v>
<v t="Michael.20120314113327.1417"><vh>02. SSS baseband IQ time domain signal</vh></v>
<v t="Michael.20120314113327.1418"><vh>03. SSS baseband IQ spectrum</vh></v>
<v t="michael.20120314211632.1426"><vh>04. SSS baseband IQ correlation</vh></v>
<v t="michael.20120314211632.1427"><vh>05. SSS baseband IQ spectrum correlation</vh></v>
<v t="michael.20120314211632.1428"><vh>06. SSS Uu signal</vh></v>
<v t="michael.20120314211632.1429"><vh>07. SSS received IQ</vh></v>
<v t="michael.20120314211632.1430"><vh>08. SSS received IQ spectrum correlation</vh></v>
<v t="michael.20120314211632.1431"><vh>09. SSS baseband detect</vh></v>
<v t="michael.20120312091134.1404"></v>
<v t="Michael.20120314113327.1416"></v>
<v t="michael.20120305092148.1293"></v>
<v t="michael.20120305092148.1296"></v>
</v>
<v t="Michael.20120314113327.1414"
expanded="Michael.20120314113327.1413,"><vh>@thin ./Simulation/SSS/sss_gen_detect.py</vh></v>
</v>
<v t="michael.20120305092148.1312"><vh>Zadoff-Chu seq</vh>
<v t="michael.20120305092148.1313"><vh>source_code</vh>
<v t="michael.20120305092148.1316"></v>
</v>
<v t="michael.20120305092148.1314"><vh>@thin ./test_files/ZC_seq.py</vh></v>
</v>
</v>
<v t="michael.20120305092148.1298"><vh>test</vh>
<v t="michael.20120305092148.1293"></v>
<v t="michael.20120305092148.1296"></v>
<v t="michael.20120305092148.1292"></v>
</v>
<v t="michael.20120305092148.1299"><vh>test_files</vh>
<v t="michael.20120305092148.1300"><vh>@thin ./test_files/simple_plot.py</vh></v>
</v>
<v t="michael.20120305092148.1297"><vh>TD-LTE</vh>
<v t="michael.20120223085633.1295"><vh>Source codes</vh>
<v t="michael.20120223085633.1281"><vh>Tools</vh>
<v t="michael.20120223085633.1287"><vh>class Point</vh></v>
</v>
<v t="michael.20120223085633.1308"><vh>class Config</vh>
<v t="michael.20120223085633.1310"><vh>get_config</vh></v>
<v t="michael.20120226084901.1395"><vh>validate_config</vh></v>
<v t="michael.20120223085633.1311"><vh>_get_RA_PREAMBLE_MAPPING</vh></v>
<v t="michael.20120223085633.1312"><vh>_get_base_config</vh></v>
<v t="michael.20120223085633.1313"><vh>_get_config</vh></v>
</v>
<v t="michael.20120223085633.1292"><vh>class RELattice</vh></v>
<v t="michael.20120223085633.1322" a="E"><vh>class TDLTE</vh>
<v t="michael.20120301114815.1252"><vh>Config</vh>
<v t="michael.20120301114815.1253"><vh>validate_config</vh></v>
<v t="michael.20120301114815.1254"><vh>process_config</vh></v>
</v>
<v t="michael.20120223085633.1336"><vh>DL_PHY</vh>
<v t="michael.20120223085633.1339"><vh>CSRS</vh>
<v t="michael.20120301114815.1386"><vh>get_CSRS_AP</vh></v>
<v t="michael.20120301114815.1387"><vh>set_CSRS_REs</vh></v>
</v>
<v t="michael.20120223085633.1344"><vh>PBCH</vh>
<v t="michael.20120223085633.1340"><vh>&lt;&lt; why force_4_port? &gt;&gt;</vh></v>
</v>
<v t="michael.20120223085633.1345"><vh>PCFICH</vh></v>
<v t="michael.20120223085633.1405" a="E"><vh>PDCCH</vh>
<v t="michael.20120301114815.1257"><vh>CCE_relative</vh>
<v t="michael.20120301114815.1379"><vh>init_REG_dict</vh></v>
<v t="michael.20120301114815.1258"><vh>get_REGs_for_subframe</vh></v>
<v t="michael.20120227090153.1248"><vh>search_space</vh></v>
</v>
<v t="michael.20120301114815.1256"><vh>get_all_REG_in_symbol</vh></v>
</v>
<v t="michael.20120223085633.1404" a="E"><vh>PHICH</vh>
<v t="michael.20120301114815.1390"><vh>phich</vh></v>
</v>
<v t="michael.20120223085633.1341"><vh>PSS</vh></v>
<v t="michael.20120223085633.1342"><vh>SSS</vh></v>
</v>
<v t="michael.20120223085633.1346"><vh>Helper_methods</vh>
<v t="michael.20120301114815.1381"><vh>dump_lattice</vh></v>
<v t="michael.20120223085633.1348"><vh>get_REG</vh></v>
<v t="michael.20120223085633.1392"><vh>get_REG_indice</vh></v>
<v t="michael.20120223085633.1394"><vh>get_REG_indice_in_symbol</vh></v>
<v t="michael.20120223085633.1386"><vh>how_many_RE_per_REG</vh></v>
<v t="michael.20120223085633.1409"><vh>init_REG</vh></v>
<v t="michael.20120223085633.1399"><vh>myfloor</vh></v>
<v t="michael.20120223085633.1401"><vh>phich</vh></v>
<v t="michael.20120223085633.1396"><vh>RE_to_REG_index</vh></v>
<v t="michael.20120223085633.1390"><vh>REG_index_to_REs</vh></v>
<v t="michael.20120223085633.1323"><vh>set_RB_background</vh></v>
<v t="michael.20120223085633.1398"><vh>set_REG_num</vh></v>
<v t="michael.20120223085633.1327"><vh>ts_to_pixel</vh></v>
</v>
<v t="michael.20120226084901.1591" a="E"><vh>PHY_Common</vh>
<v t="michael.20120226084901.1595"><vh>16QAM</vh></v>
<v t="michael.20120226084901.1596"><vh>64QAM</vh></v>
<v t="michael.20120301114815.1384"><vh>_init_re_size_lattice</vh></v>
<v t="michael.20120301114815.1385"><vh>_init_re_lattice</vh></v>
<v t="michael.20120301114815.1382"><vh>_init_re_usage_lattice</vh></v>
<v t="michael.20120226084901.1593"><vh>BPSK</vh></v>
<v t="michael.20120226084901.1592"><vh>c</vh></v>
<v t="michael.20120226084901.1594"><vh>QPSK</vh></v>
<v t="michael.20120226084901.1597"><vh>x_1</vh></v>
<v t="michael.20120226084901.1598"><vh>x_2</vh></v>
</v>
<v t="michael.20120223085633.1343"><vh>Sepcial_subframe_Relative</vh>
<v t="michael.20120223085633.1331"><vh>get_DwPTS_symbol_num</vh></v>
<v t="michael.20120223085633.1328"><vh>get_DwPTS_Ts</vh></v>
<v t="michael.20120223085633.1330"><vh>get_GAP_Ts</vh></v>
<v t="michael.20120223085633.1332"><vh>get_UpPTS_symbol_num</vh></v>
<v t="michael.20120223085633.1329"><vh>get_UpPTS_Ts</vh></v>
</v>
<v t="michael.20120223085633.1407"><vh>UL_PHY</vh>
<v t="michael.20120223085633.1406"><vh>PRACH</vh></v>
</v>
</v>
<v t="michael.20120223085633.1296"><vh>class ImageDrawer</vh>
<v t="michael.20120223085633.1321"><vh>add_labels</vh></v>
<v t="michael.20120223085633.1300"><vh>draw</vh></v>
<v t="michael.20120223085633.1333"><vh>_draw_lattice</vh></v>
<v t="michael.20120223085633.1334"><vh>_draw_REs</vh></v>
<v t="michael.20120223085633.1298"><vh>initialize_drawer</vh></v>
<v t="michael.20120226084901.1590"><vh>_draw_legend</vh></v>
<v t="michael.20120227090153.1249"><vh>_draw_mark</vh></v>
</v>
</v>
<v t="michael.20120223085633.1293"><vh>Release files</vh>
<v t="michael.20120226084901.1394"
expanded="michael.20120223085633.1322,michael.20120223085633.1405,michael.20120223085633.1404,michael.20120226084901.1591,"><vh>@thin ./lte-phy-channel-on-air.py</vh></v>
</v>
<v t="michael.20120223085633.1294"><vh>Test files</vh>
<v t="michael.20120223085633.1301"
expanded="michael.20120223085633.1322,michael.20120223085633.1405,michael.20120223085633.1404,michael.20120226084901.1591,"><vh>@thin ./test_files/testImageDrawer.py</vh></v>
<v t="michael.20120301114815.1380"
expanded="michael.20120223085633.1322,michael.20120223085633.1405,michael.20120223085633.1404,michael.20120226084901.1591,"><vh>@thin ./test_files/profile.py</vh></v>
<v t="michael.20120223085633.1324"
expanded="michael.20120223085633.1322,michael.20120223085633.1405,michael.20120223085633.1404,michael.20120226084901.1591,"><vh>@thin ./test_files/testTDLTE.py</vh></v>
<v t="michael.20120301114815.1318"
expanded="michael.20120223085633.1322,michael.20120223085633.1405,michael.20120223085633.1404,michael.20120226084901.1591,"><vh>@thin ./test_files/testInit_CCE_for_PDCCH.py</vh></v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="Michael.20120314113327.1412"></t>
<t tx="Michael.20120314113327.1413">
from scipy.signal import *
from numpy import *
import matplotlib.pyplot as plt

# time scale is in 1 s
T_s = 1.0/30720/1000 # in s

# configuration for SSS
l = 6
N_DL_RB = 110
N_RB_sc = 12
N_DL_CP = 0 # normal DL CP
N_ID_2_tuple = (0,1,2)
delta_f = 15000
subframe = 0
N_ID_cell = 0
f_0 = (2620+0.1*(2620-2750))*1000*1000  # in Hz

if N_DL_CP==0 and delta_f==15000:
    if l==0:
        N_CP_l = 160
    else:
        N_CP_l = 144
elif N_DL_CP==1:    # extended CP
    if delta_f==15000:
        N_CP_l = 512
    else:   # delta_f == 7500
        N_CP_l = 1024
if delta_f==15000:
    N = 2048
else:   # delta_f == 7500
    N = 4096

t = arange(0, (N_CP_l+N)*T_s, T_s)

def find_max( a_list ):
    m = max(a_list)
    for i in arange(len(a_list)):
        if a_list[i] == m:
            return (i, m)

def find_min( a_array ):
    x, y = 0, 0
    for i in arange(len(a_array)):
        if a_array[i] &lt; y:
            x, y = i, a_array[i]
    return (x,y)

def find_abs_max( a_array ):
    m = max(abs(a_array))
    for i in arange(len(a_array)):
        if abs(a_array[i]) == m:
            return (i, m)

            
@others

test_enabling_bits = 0b111111111

# 01. SSS sequence generation
if test_enabling_bits &amp; (1&lt;&lt;0):
    SSS_sequence_generation()

# 02. SSS baseband signal
if test_enabling_bits &amp; (1&lt;&lt;1):
    sss_baseband_IQ()

# 03. SSS baseband IQ
if test_enabling_bits &amp; (1&lt;&lt;2):
    sss_baseband_IQ_spectrum()

# 04. SSS baseband IQ correlation
if test_enabling_bits &amp; (1&lt;&lt;3):
    sss_baseband_IQ_correlation()

# 05. SSS baseband IQ spectrum correlation
if test_enabling_bits &amp; (1&lt;&lt;4):
    sss_baseband_IQ_spectrum_correlation()

# 06. SSS Uu signal
if test_enabling_bits &amp; (1&lt;&lt;5):
    SSS_signal_Uu()

# 07. SSS received IQ
if test_enabling_bits &amp; (1&lt;&lt;6):
    SSS_received_IQ()

# 08. SSS received IQ spectrum correlation
if test_enabling_bits &amp; (1&lt;&lt;7):
    SSS_received_IQ_spectrum_correlation()

# 09. SSS baseband detect
if test_enabling_bits &amp; (1&lt;&lt;8):
    test_SSS_detect_in_baseband_IQ()
</t>
<t tx="Michael.20120314113327.1415">def SSS_sequence_generation(action='load'):
    import cPickle
    if action=='init':
        sss_dict = dict()   # key is (N_ID_cell, subframe)
        N_ID_cell_list = list()
        for N_ID_1 in range(168):
            for N_ID_2 in range(3):
                N_ID_cell = N_ID_1*3 + N_ID_2
                N_ID_cell_list.append(N_ID_cell)
                for subframe in (0,5):
                    sss_dict[(N_ID_cell,subframe)] = sss_seq(subframe,N_ID_cell)
        f = open('sss_dict.dump','w')
        cPickle.dump(sss_dict,f)
        f.close()
    elif action=='load':
        f = open('sss_dict.dump','r')
        sss_dict = cPickle.load(f)
    return sss_dict
    
</t>
<t tx="Michael.20120314113327.1416">def sss_symbol_array(subframe, N_ID_cell, N_DL_RB, N_RB_sc):
    symbol_array = ndarray( shape=(N_DL_RB*N_RB_sc,), dtype=complex128 )
    for i in arange(len(symbol_array)):
        symbol_array[i] = 0
    for n in arange(0, 62):
        k = n-31+N_DL_RB*N_RB_sc/2
        symbol_array[k] = sss_d(n, subframe, N_ID_cell)
    return symbol_array
</t>
<t tx="Michael.20120314113327.1417">def sss_baseband_IQ():
    
    sss_re_array = sss_symbol_array(subframe, N_ID_cell, N_DL_RB, N_RB_sc)
    sss_baseband_IQ = s_p_l(sss_re_array, l, N_DL_RB, N_RB_sc, N_DL_CP, delta_f)
    
    subplot_pos_tupe = (131,132,133)
    title_tuple = ('SSS baseband IQ OFDM signal magnitude','SSS baseband IQ OFDM signal real part','SSS baseband IQ OFDM signal imag part')
    y_label_tuple = ('IQ Magnitude', 'I part', 'Q part')
    func_tuple = (abs, real, imag)
        
    for i in (0,1,2):
        plt.subplot(subplot_pos_tupe[i])
        plt.title(title_tuple[i])
        plt.plot(t*1000, func_tuple[i](sss_baseband_IQ))
        plt.xlabel('Time (ms)')
        plt.ylabel(y_label_tuple[i])
        #plt.axis([-0.01, 0.075, 0, 15])
        plt.legend( ('N_ID_cell=%s'%N_ID_cell,) )
            
    plt.show()
    
</t>
<t tx="Michael.20120314113327.1418">def sss_baseband_IQ_spectrum():
    
    sss_re_array = sss_symbol_array(subframe, N_ID_cell, N_DL_RB, N_RB_sc)
    sss_baseband_IQ = s_p_l(sss_re_array, l, N_DL_RB, N_RB_sc, N_DL_CP, delta_f)[-1*N:]
    sss_baseband_IQ_fft = fft.fft(sss_baseband_IQ, N)
    
    legend_list = list()
    plt.title('SSS baseband IQ spectrum for N_ID_cell=%s'%N_ID_cell)
    legend_list.append( 'Spectrum magnitude' )
    plt.plot(abs(sss_baseband_IQ_fft), linestyle='-')
    plt.xlabel('n (FFT index)')
    plt.ylabel('Spectrum magnitude')
    plt.legend(legend_list)
    plt.show()
</t>
<t tx="michael.20120223085633.1280">@language python
@tabwidth -4
@encoding utf-8
</t>
<t tx="michael.20120223085633.1281">@others
</t>
<t tx="michael.20120223085633.1287">class Point:
    def __init__(self,x,y):
        self.x, self.y = x,y
    
    def __add__(self, p):
        if type(p) == tuple:
            x,y = p
            return Point(self.x+x,self.y+y)
        else:
            return Point(self.x+p.x,self.y+p.y)
    
    def __sub__(self, p):
        return Point(self.x-p.x,self.y-p.y)

    def __str__(self):
        return "%s, %s" % (self.x,self.y)

Size = Point
</t>
<t tx="michael.20120223085633.1292"># totally reuse dict
# key is (SFN, subframe, l, k)
# value is a color together with alpha: (R, G, B, A)
RELattice = dict

# key is also (SFN, subframe, l, k)
# value is the size of this RE in Ts
class RESizeLattice(dict):
    def __init__(self):
        dict.__init__(self)
        self.DwPTS_width, self.GAP_width, self.UpPTS_width =0,0,0
        
</t>
<t tx="michael.20120223085633.1293"></t>
<t tx="michael.20120223085633.1294"></t>
<t tx="michael.20120223085633.1295"># RE position representation:
    # (frame, slot, l, k)
    # frame num.
    # slot num. from 0 to 19
    # l : OFDM symbol index
    # k: subcarrier index</t>
<t tx="michael.20120223085633.1296">from copy import deepcopy
import md5
from time import time
import Image, ImageDraw

class ImageDrawer:
    def __init__(self, config, re_lattice, re_size_lattice):
        self.config = config
        self.re_lattice = re_lattice
        self.re_size_lattice = re_size_lattice
        self.initialize_drawer()
        self.RB_count = 0
        self.draw('lte-phy-channel-on-air.png')
    
    @others
</t>
<t tx="michael.20120223085633.1298">def initialize_drawer(self):
    
    width = 0
    for frame in range(self.config['start_SFN'],self.config['start_SFN']+self.config['frame_num']):
        for subframe in range(10):
            for l in range(2*7):
                if self.re_size_lattice.has_key( (frame,subframe,l,0) ):
                    width += round(self.re_size_lattice[(frame,subframe,l,0)][0]/(2048+144.)*self.config['cell_width'])
            if frame==0 and subframe==0:
                pass
            else:
                width += 1
    self.config['lattice_width'] = int(width)
    self.config['lattice_height'] = self.config['cell_height']*self.config['N_DL_RB']*12
    self.config['image_width'] = self.config['lattice_width'] + 30
    self.config['image_height'] = self.config['lattice_height'] + 70
    
    self.image = Image.new("RGB",(self.config['image_width'],self.config['image_height']),(255,255,255))
    self.dc = ImageDraw.Draw(self.image)
    
    #self.config['RB_height'] = self.config['cell_height'] * self.config['N_RB_sc']
    #self.config['UL_RB_width'] = self.config['cell_width'] * self.config['N_UL_symb']
    #self.config['DL_RB_width'] = self.config['cell_width'] * self.config['N_DL_symb']
    #self.config['special_RB_width'] = self.config['cell_width'] * 7
    #self.config['UL_subframe_width'] = self.config['UL_RB_width'] *2
    #self.config['DL_subframe_width'] = self.config['DL_RB_width'] *2
    #self.config['special_subframe_width'] = self.config['cell_width'] *7 *2
    #self.config['frame_width'] = self.config['UL_DL_S'].count('U')*self.config['UL_subframe_width'] + self.config['UL_DL_S'].count('D')*self.config['DL_subframe_width'] + self.config['UL_DL_S'].count('S')*self.config['special_subframe_width']
    #self.config['width'] = self.config['frame_width'] * self.config['frame_num']+20
    #self.config['height'] = self.config['cell_height']*self.config['N_DL_RB']*12 +20
    
</t>
<t tx="michael.20120223085633.1300">def draw(self, file_name):
    start_time = time()
    #print 'MainView.MainView.draw_to_bitmap starts'
    
    self._draw_lattice()
    self._draw_REs()
    self._draw_legend()
    self._draw_mark()
        
        
        #self.draw_frame( dc, deepcopy(start_pos) )
        #self.draw_frame( deepcopy(start_pos) )
        #start_pos.x += self.config['frame_width'] + self.config['frame_interval']
#           print 'start_pos is ', start_pos
    # draw physical resource allocation
    
    #self.add_labels()
    
    #print 'in MainView.MainView.draw_to_bitmap, just before save to file.  ',time()-start_time
    
    self.image.save(file_name)
    #print 'MainView.MainView.draw_to_bitmap ends.  ',time()-start_time

</t>
<t tx="michael.20120223085633.1308">class Config:
    
    def __init__(self):
        #self.dir = '.'+os.sep+'Config'+os.sep
        self.config = self._get_config('config.txt')
        self.config['RA_PREAMBLE_MAPPING'] = self._get_RA_PREAMBLE_MAPPING()
        self.config['AppName'] = 'lte-phy-channel-on-air'
        self.config['version'] = '2.0'
        self.validate_config()

    @others
</t>
<t tx="michael.20120223085633.1310">def get_config(self):
    return self.config
</t>
<t tx="michael.20120223085633.1311">def _get_RA_PREAMBLE_MAPPING(self):
    # key: (PRACH_configuration_index, UL/DL_configuration)
    # value: a tuple of preamble mapping in time and frequency
    d = dict()
    
    d[(0,0)] = ( (0,1,0,2), )
    d[(0,1)] = ( (0,1,0,1), )
    d[(0,2)] = ( (0,1,0,0), )
    d[(0,3)] = ( (0,1,0,2), )
    d[(0,4)] = ( (0,1,0,1), )
    d[(0,5)] = ( (0,1,0,0), )
    d[(0,6)] = ( (0,1,0,2), )
    
    d[(1,0)] = ( (0,2,0,2), )
    d[(1,1)] = ( (0,2,0,1), )
    d[(1,2)] = ( (0,2,0,0), )
    d[(1,3)] = ( (0,2,0,2), )
    d[(1,4)] = ( (0,2,0,1), )
    d[(1,5)] = ( (0,2,0,0), )
    d[(1,6)] = ( (0,2,0,2), )
    
    d[(2,0)] = ( (0,1,1,2), )
    d[(2,1)] = ( (0,1,1,1), )
    d[(2,2)] = ( (0,1,1,0), )
    d[(2,3)] = ( (0,1,0,1), )
    d[(2,4)] = ( (0,1,0,0), )
    d[(2,5)] = (  )
    d[(2,6)] = ( (0,1,1,1), )
    
    d[(3,0)] = ( (0,0,0,2), )
    d[(3,1)] = ( (0,0,0,1), )
    d[(3,2)] = ( (0,0,0,0), )
    d[(3,3)] = ( (0,0,0,2), )
    d[(3,4)] = ( (0,0,0,1), )
    d[(3,5)] = ( (0,0,0,0), )
    d[(3,6)] = ( (0,0,0,2), )
    
    d[(4,0)] = ( (0,0,1,2), )
    d[(4,1)] = ( (0,0,1,1), )
    d[(4,2)] = ( (0,0,1,0), )
    d[(4,3)] = ( (0,0,0,1), )
    d[(4,4)] = ( (0,0,0,0), )
    d[(4,5)] = (  )
    d[(4,6)] = ( (0,0,1,1), )
    
    d[(5,0)] = ( (0,0,0,1), )
    d[(5,1)] = ( (0,0,0,0), )
    d[(5,2)] = (  )
    d[(5,3)] = ( (0,0,0,0), )
    d[(5,4)] = (  )
    d[(5,5)] = (  )
    d[(5,6)] = ( (0,0,0,1), )
    
    d[(6,0)] = ( (0,0,0,2),(0,0,1,2) )
    d[(6,1)] = ( (0,0,0,1),(0,0,1,1) )
    d[(6,2)] = ( (0,0,0,0),(0,0,1,0) )
    d[(6,3)] = ( (0,0,0,1),(0,0,0,2) )
    d[(6,4)] = ( (0,0,0,0),(0,0,0,1) )
    d[(6,5)] = ( (0,0,0,0),(1,0,0,0) )
    d[(6,6)] = ( (0,0,0,2),(0,0,1,1) )
    
    d[(7,0)] = ( (0,0,0,1),(0,0,1,1) )
    d[(7,1)] = ( (0,0,0,0),(0,0,1,0) )
    d[(7,2)] = (  )
    d[(7,3)] = ( (0,0,0,0),(0,0,0,2) )
    d[(7,4)] = (  )
    d[(7,5)] = (  )
    d[(7,6)] = ( (0,0,0,1),(0,0,1,0) )
    
    d[(8,0)] = ( (0,0,0,0),(0,0,1,0) )
    d[(8,1)] = (  )
    d[(8,2)] = (  )
    d[(8,3)] = ( (0,0,0,0),(0,0,0,1) )
    d[(8,4)] = (  )
    d[(8,5)] = (  )
    d[(8,6)] = ( (0,0,0,0),(0,0,1,1) )
    
    d[(9,0)] = ( (0,0,0,1),(0,0,0,2),(0,0,1,2) )
    d[(9,1)] = ( (0,0,0,0),(0,0,0,1),(0,0,1,1) )
    d[(9,2)] = ( (0,0,0,0),(0,0,1,0),(1,0,0,0) )
    d[(9,3)] = ( (0,0,0,0),(0,0,0,1),(0,0,0,2) )
    d[(9,4)] = ( (0,0,0,0),(0,0,0,1),(1,0,0,1) )
    d[(9,5)] = ( (0,0,0,0),(1,0,0,0),(2,0,0,0) )
    d[(9,6)] = ( (0,0,0,1),(0,0,0,2),(0,0,1,1) )
    
    d[(10,0)] = ( (0,0,0,0),(0,0,1,0),(0,0,1,1) )
    d[(10,1)] = ( (0,0,0,1),(0,0,1,0),(0,0,1,1) )
    d[(10,2)] = ( (0,0,0,0),(0,0,1,0),(1,0,1,0) )
    d[(10,3)] = (  )
    d[(10,4)] = ( (0,0,0,0),(0,0,0,1),(1,0,0,0) )
    d[(10,5)] = (  )
    d[(10,6)] = ( (0,0,0,0),(0,0,0,2),(0,0,1,0) )
    
    
    d[(11,0)] = (  )
    d[(11,1)] = ( (0,0,0,0),(0,0,0,1),(0,0,1,0) )
    d[(11,2)] = (  )
    d[(11,3)] = (  )
    d[(11,4)] = (  )
    d[(11,5)] = (  )
    d[(11,6)] = ( (0,0,0,1),(0,0,1,0),(0,0,1,1) )
    
    d[(12,0)] = ( (0,0,0,1),(0,0,0,2),(0,0,1,1),(0,0,1,2) )
    d[(12,1)] = ( (0,0,0,0),(0,0,0,1),(0,0,1,0),(0,0,1,1) )
    d[(12,2)] = ( (0,0,0,0),(0,0,1,0),(1,0,0,0),(1,0,1,0) )
    d[(12,3)] = ( (0,0,0,0),(0,0,0,1),(0,0,0,2),(1,0,0,2) )
    d[(12,4)] = ( (0,0,0,0),(0,0,0,1),(1,0,0,0),(1,0,0,1) )
    d[(12,5)] = ( (0,0,0,0),(1,0,0,0),(2,0,0,0),(3,0,0,0) )
    d[(12,6)] = ( (0,0,0,1),(0,0,0,2),(0,0,1,0),(0,0,1,1) )
    
    d[(13,0)] = ( (0,0,0,0),(0,0,0,2),(0,0,1,0),(0,0,1,2) )
    d[(13,1)] = (  )
    d[(13,2)] = (  )
    d[(13,3)] = ( (0,0,0,0),(0,0,0,1),(0,0,0,2),(1,0,0,1) )
    d[(13,4)] = (  )
    d[(13,5)] = (  )
    d[(13,6)] = ( (0,0,0,0),(0,0,0,1),(0,0,0,2),(0,0,1,1) )
    
    d[(14,0)] = ( (0,0,0,0),(0,0,0,1),(0,0,1,0),(0,0,1,1) )
    d[(14,1)] = (  )
    d[(14,2)] = (  )
    d[(14,3)] = ( (0,0,0,0),(0,0,0,1),(0,0,0,2),(1,0,0,0) )
    d[(14,4)] = (  )
    d[(14,5)] = (  )
    d[(14,6)] = ( (0,0,0,0),(0,0,0,2),(0,0,1,0),(0,0,1,1) )
    
    d[(15,0)] = ( (0,0,0,0),(0,0,0,1),(0,0,0,2),(0,0,1,1),(0,0,1,2) )
    d[(15,1)] = ( (0,0,0,0),(0,0,0,1),(0,0,1,0),(0,0,1,1),(1,0,0,1) )
    d[(15,2)] = ( (0,0,0,0),(0,0,1,0),(1,0,0,0),(1,0,1,0),(2,0,0,0) )
    d[(15,3)] = ( (0,0,0,0),(0,0,0,1),(0,0,0,2),(1,0,0,1),(1,0,0,2) )
    d[(15,4)] = ( (0,0,0,0),(0,0,0,1),(1,0,0,0),(1,0,0,1),(2,0,0,1) )
    d[(15,5)] = ( (0,0,0,0),(1,0,0,0),(2,0,0,0),(3,0,0,0),(4,0,0,0) )
    d[(15,6)] = ( (0,0,0,0),(0,0,0,1),(0,0,0,2),(0,0,1,0),(0,0,1,1) )
    
    d[(16,0)] = ( (0,0,0,1),(0,0,0,2),(0,0,1,0),(0,0,1,1),(0,0,1,2) )
    d[(16,1)] = ( (0,0,0,0),(0,0,0,1),(0,0,1,0),(0,0,1,1),(1,0,1,1) )
    d[(16,2)] = ( (0,0,0,0),(0,0,1,0),(1,0,0,0),(1,0,1,0),(2,0,1,0) )
    d[(16,3)] = ( (0,0,0,0),(0,0,0,1),(0,0,0,2),(1,0,0,0),(1,0,0,2) )
    d[(16,4)] = ( (0,0,0,0),(0,0,0,1),(1,0,0,0),(1,0,0,1),(2,0,0,0) )
    d[(16,5)] = (  )
    d[(16,6)] = (  )
    
    d[(17,0)] = ( (0,0,0,0),(0,0,0,1),(0,0,0,2),(0,0,1,0),(0,0,1,2) )
    d[(17,1)] = ( (0,0,0,0),(0,0,0,1),(0,0,1,0),(0,0,1,1),(1,0,0,0) )
    d[(17,2)] = (  )
    d[(17,3)] = ( (0,0,0,0),(0,0,0,1),(0,0,0,2),(1,0,0,0),(1,0,0,1) )
    d[(17,4)] = (  )
    d[(17,5)] = (  )
    d[(17,6)] = (  )
    
    d[(18,0)] = ( (0,0,0,0),(0,0,0,1),(0,0,0,2),(0,0,1,0),(0,0,1,1),(0,0,1,2) )
    d[(18,1)] = ( (0,0,0,0),(0,0,0,1),(0,0,1,0),(0,0,1,1),(1,0,0,1),(1,0,1,1) )
    d[(18,2)] = ( (0,0,0,0),(0,0,1,0),(1,0,0,0),(1,0,1,0),(2,0,0,0),(2,0,1,0) )
    d[(18,3)] = ( (0,0,0,0),(0,0,0,1),(0,0,0,2),(1,0,0,0),(1,0,0,1),(1,0,0,2) )
    d[(18,4)] = ( (0,0,0,0),(0,0,0,1),(1,0,0,0),(1,0,0,1),(2,0,0,0),(2,0,0,1) )
    d[(18,5)] = ( (0,0,0,0),(1,0,0,0),(2,0,0,0),(3,0,0,0),(4,0,0,0),(5,0,0,0) )
    d[(18,6)] = ( (0,0,0,0),(0,0,0,1),(0,0,0,2),(0,0,1,0),(0,0,1,1),(1,0,0,2) )
    
    d[(19,0)] = (  )
    d[(19,1)] = ( (0,0,0,0),(0,0,0,1),(0,0,1,0),(0,0,1,1),(1,0,0,0),(1,0,1,0) )
    d[(19,2)] = (  )
    d[(19,3)] = (  )
    d[(19,4)] = (  )
    d[(19,5)] = (  )
    d[(19,6)] = ( (0,0,0,0),(0,0,0,1),(0,0,0,2),(0,0,1,0),(0,0,1,1),(1,0,1,1) )
    
    d[(20,0)] = ( (0,1,0,1), )
    d[(20,1)] = ( (0,1,0,0), )
    d[(20,2)] = (  )
    d[(20,3)] = ( (0,1,0,1), )
    d[(20,4)] = ( (0,1,0,0), )
    d[(20,5)] = (  )
    d[(20,6)] = ( (0,1,0,1), )
    d[(30,0)] = d[(20,0)]
    d[(30,1)] = d[(20,1)]
    d[(30,2)] = d[(20,2)]
    d[(30,3)] = d[(20,3)]
    d[(30,4)] = d[(20,4)]
    d[(30,5)] = d[(20,5)]
    d[(30,6)] = d[(20,6)]
    
    d[(21,0)] = ( (0,2,0,1), )
    d[(21,1)] = ( (0,2,0,0), )
    d[(21,2)] = (  )
    d[(21,3)] = ( (0,2,0,1), )
    d[(21,4)] = ( (0,2,0,0), )
    d[(21,5)] = (  )
    d[(21,6)] = ( (0,2,0,1), )
    d[(31,0)] = d[(21,0)]
    d[(31,1)] = d[(21,1)]
    d[(31,2)] = d[(21,2)]
    d[(31,3)] = d[(21,3)]
    d[(31,4)] = d[(21,4)]
    d[(31,5)] = d[(21,5)]
    d[(31,6)] = d[(21,6)]
    
    d[(22,0)] = ( (0,1,1,1), )
    d[(22,1)] = ( (0,1,1,0), )
    d[(22,2)] = (  )
    d[(22,3)] = (  )
    d[(22,4)] = (  )
    d[(22,5)] = (  )
    d[(22,6)] = ( (0,1,1,0), )
    d[(32,0)] = d[(22,0)]
    d[(32,1)] = d[(22,1)]
    d[(32,2)] = d[(22,2)]
    d[(32,3)] = d[(22,3)]
    d[(32,4)] = d[(22,4)]
    d[(32,5)] = d[(22,5)]
    d[(32,6)] = d[(22,6)]
    
    d[(23,0)] = ( (0,0,0,1), )
    d[(23,1)] = ( (0,0,0,0), )
    d[(23,2)] = (  )
    d[(23,3)] = ( (0,0,0,1), )
    d[(23,4)] = ( (0,0,0,0), )
    d[(23,5)] = (  )
    d[(23,6)] = ( (0,0,0,1), )
    d[(33,0)] = d[(23,0)]
    d[(33,1)] = d[(23,1)]
    d[(33,2)] = d[(23,2)]
    d[(33,3)] = d[(23,3)]
    d[(33,4)] = d[(23,4)]
    d[(33,5)] = d[(23,5)]
    d[(33,6)] = d[(23,6)]
    
    d[(24,0)] = ( (0,0,1,1), )
    d[(24,1)] = ( (0,0,1,0), )
    d[(24,2)] = (  )
    d[(24,3)] = (  )
    d[(24,4)] = (  )
    d[(24,5)] = (  )
    d[(24,6)] = ( (0,0,1,0), )
    d[(34,0)] = d[(24,0)]
    d[(34,1)] = d[(24,1)]
    d[(34,2)] = d[(24,2)]
    d[(34,3)] = d[(24,3)]
    d[(34,4)] = d[(24,4)]
    d[(34,5)] = d[(24,5)]
    d[(34,6)] = d[(24,6)]
    
    d[(25,0)] = ( (0,0,0,1),(0,0,1,1) )
    d[(25,1)] = ( (0,0,0,0),(0,0,1,0) )
    d[(25,2)] = (  )
    d[(25,3)] = ( (0,0,0,1),(1,0,0,1) )
    d[(25,4)] = ( (0,0,0,0),(1,0,0,0) )
    d[(25,5)] = (  )
    d[(25,6)] = ( (0,0,0,1),(0,0,1,0) )
    d[(35,0)] = d[(25,0)]
    d[(35,1)] = d[(25,1)]
    d[(35,2)] = d[(25,2)]
    d[(35,3)] = d[(25,3)]
    d[(35,4)] = d[(25,4)]
    d[(35,5)] = d[(25,5)]
    d[(35,6)] = d[(25,6)]
    
    d[(26,0)] = ( (0,0,0,1),(0,0,1,1),(1,0,0,1) )
    d[(26,1)] = ( (0,0,0,0),(0,0,1,0),(1,0,0,0) )
    d[(26,2)] = (  )
    d[(26,3)] = ( (0,0,0,1),(1,0,0,1),(2,0,0,1) )
    d[(26,4)] = ( (0,0,0,0),(1,0,0,0),(2,0,0,0) )
    d[(26,5)] = (  )
    d[(26,6)] = ( (0,0,0,1),(0,0,1,0),(1,0,0,1) )
    d[(36,0)] = d[(26,0)]
    d[(36,1)] = d[(26,1)]
    d[(36,2)] = d[(26,2)]
    d[(36,3)] = d[(26,3)]
    d[(36,4)] = d[(26,4)]
    d[(36,5)] = d[(26,5)]
    d[(36,6)] = d[(26,6)]
    
    d[(27,0)] = ( (0,0,0,1),(0,0,1,1),(1,0,0,1),(1,0,1,1) )
    d[(27,1)] = ( (0,0,0,0),(0,0,1,0),(1,0,0,0),(1,0,1,0) )
    d[(27,2)] = (  )
    d[(27,3)] = ( (0,0,0,1),(1,0,0,1),(2,0,0,1),(3,0,0,1) )
    d[(27,4)] = ( (0,0,0,0),(1,0,0,0),(2,0,0,0),(3,0,0,0) )
    d[(27,5)] = (  )
    d[(27,6)] = ( (0,0,0,1),(0,0,1,0),(1,0,0,1),(1,0,1,0) )
    d[(37,0)] = d[(27,0)]
    d[(37,1)] = d[(27,1)]
    d[(37,2)] = d[(27,2)]
    d[(37,3)] = d[(27,3)]
    d[(37,4)] = d[(27,4)]
    d[(37,5)] = d[(27,5)]
    d[(37,6)] = d[(27,6)]
    
    d[(28,0)] = ( (0,0,0,1),(0,0,1,1),(1,0,0,1),(1,0,1,1),(2,0,0,1) )
    d[(28,1)] = ( (0,0,0,0),(0,0,1,0),(1,0,0,0),(1,0,1,0),(2,0,0,0) )
    d[(28,2)] = (  )
    d[(28,3)] = ( (0,0,0,1),(1,0,0,1),(2,0,0,1),(3,0,0,1),(4,0,0,1) )
    d[(28,4)] = ( (0,0,0,0),(1,0,0,0),(2,0,0,0),(3,0,0,0),(4,0,0,0) )
    d[(28,5)] = (  )
    d[(28,6)] = ( (0,0,0,1),(0,0,1,0),(1,0,0,1),(1,0,1,0),(2,0,0,1) )
    d[(38,0)] = d[(28,0)]
    d[(38,1)] = d[(28,1)]
    d[(38,2)] = d[(28,2)]
    d[(38,3)] = d[(28,3)]
    d[(38,4)] = d[(28,4)]
    d[(38,5)] = d[(28,5)]
    d[(38,6)] = d[(28,6)]
    
    d[(29,0)] = ( (0,0,0,1),(0,0,1,1),(1,0,0,1),(1,0,1,1),(2,0,0,1),(2,0,1,1) )
    d[(29,1)] = ( (0,0,0,0),(0,0,1,0),(1,0,0,0),(1,0,1,0),(2,0,0,0),(2,0,1,0) )
    d[(29,2)] = (  )
    d[(29,3)] = ( (0,0,0,1),(1,0,0,1),(2,0,0,1),(3,0,0,1),(4,0,0,1),(5,0,0,1) )
    d[(29,4)] = ( (0,0,0,0),(1,0,0,0),(2,0,0,0),(3,0,0,0),(4,0,0,0),(5,0,0,0) )
    d[(29,5)] = (  )
    d[(29,6)] = ( (0,0,0,1),(0,0,1,0),(1,0,0,1),(1,0,1,0),(2,0,0,1),(2,0,1,0) )
    d[(39,0)] = d[(29,0)]
    d[(39,1)] = d[(29,1)]
    d[(39,2)] = d[(29,2)]
    d[(39,3)] = d[(29,3)]
    d[(39,4)] = d[(29,4)]
    d[(39,5)] = d[(29,5)]
    d[(39,6)] = d[(29,6)]
    
    d[(40,0)] = ( (0,1,0,0), )
    d[(40,1)] = (  )
    d[(40,2)] = (  )
    d[(40,3)] = ( (0,1,0,0), )
    d[(40,4)] = (  )
    d[(40,5)] = (  )
    d[(40,6)] = ( (0,1,0,0), )
    
    d[(41,0)] = ( (0,2,0,0), )
    d[(41,1)] = (  )
    d[(41,2)] = (  )
    d[(41,3)] = ( (0,2,0,0), )
    d[(41,4)] = (  )
    d[(41,5)] = (  )
    d[(41,6)] = ( (0,2,0,0), )
    
    d[(42,0)] = ( (0,1,1,0), )
    d[(42,1)] = (  )
    d[(42,2)] = (  )
    d[(42,3)] = (  )
    d[(42,4)] = (  )
    d[(42,5)] = (  )
    d[(42,6)] = (  )
    
    d[(43,0)] = ( (0,0,0,0), )
    d[(43,1)] = (  )
    d[(43,2)] = (  )
    d[(43,3)] = ( (0,0,0,0), )
    d[(43,4)] = (  )
    d[(43,5)] = (  )
    d[(43,6)] = ( (0,0,0,0), )
    
    d[(44,0)] = ( (0,0,1,0), )
    d[(44,1)] = (  )
    d[(44,2)] = (  )
    d[(44,3)] = (  )
    d[(44,4)] = (  )
    d[(44,5)] = (  )
    d[(44,6)] = (  )
    
    d[(45,0)] = ( (0,0,0,0),(0,0,1,0) )
    d[(45,1)] = (  )
    d[(45,2)] = (  )
    d[(45,3)] = ( (0,0,0,0),(1,0,0,0) )
    d[(45,4)] = (  )
    d[(45,5)] = (  )
    d[(45,6)] = ( (0,0,0,0),(1,0,0,0) )
    
    d[(46,0)] = ( (0,0,0,0),(0,0,1,0),(1,0,0,0) )
    d[(46,1)] = (  )
    d[(46,2)] = (  )
    d[(46,3)] = ( (0,0,0,0),(1,0,0,0),(2,0,0,0) )
    d[(46,4)] = (  )
    d[(46,5)] = (  )
    d[(46,6)] = ( (0,0,0,0),(1,0,0,0),(2,0,0,0) )
    
    d[(47,0)] = ( (0,0,0,0),(0,0,1,0),(1,0,0,0),(1,0,1,0) )
    d[(47,1)] = (  )
    d[(47,2)] = (  )
    d[(47,3)] = ( (0,0,0,0),(1,0,0,0),(2,0,0,0),(3,0,0,0) )
    d[(47,4)] = (  )
    d[(47,5)] = (  )
    d[(47,6)] = ( (0,0,0,0),(1,0,0,0),(2,0,0,0),(3,0,0,0) )
    
    d[(48,0)] = ( (0,1,0,-1), )
    d[(48,1)] = ( (0,1,0,-1), )
    d[(48,2)] = ( (0,1,0,-1), )
    d[(48,3)] = ( (0,1,0,-1), )
    d[(48,4)] = ( (0,1,0,-1), )
    d[(48,5)] = ( (0,1,0,-1), )
    d[(48,6)] = ( (0,1,0,-1), )
    
    d[(49,0)] = ( (0,2,0,-1), )
    d[(49,1)] = ( (0,2,0,-1), )
    d[(49,2)] = ( (0,2,0,-1), )
    d[(49,3)] = ( (0,2,0,-1), )
    d[(49,4)] = ( (0,2,0,-1), )
    d[(49,5)] = ( (0,2,0,-1), )
    d[(49,6)] = ( (0,2,0,-1), )
    
    d[(50,0)] = ( (0,1,1,-1), )
    d[(50,1)] = ( (0,1,1,-1), )
    d[(50,2)] = ( (0,1,1,-1), )
    d[(50,3)] = (  )
    d[(50,4)] = (  )
    d[(50,5)] = (  )
    d[(50,6)] = ( (0,1,1,-1), )
    
    d[(51,0)] = ( (0,0,0,-1), )
    d[(51,1)] = ( (0,0,0,-1), )
    d[(51,2)] = ( (0,0,0,-1), )
    d[(51,3)] = ( (0,0,0,-1), )
    d[(51,4)] = ( (0,0,0,-1), )
    d[(51,5)] = ( (0,0,0,-1), )
    d[(51,6)] = ( (0,0,0,-1), )
    
    d[(52,0)] = ( (0,0,1,-1), )
    d[(52,1)] = ( (0,0,1,-1), )
    d[(52,2)] = ( (0,0,1,-1), )
    d[(52,3)] = (  )
    d[(52,4)] = (  )
    d[(52,5)] = (  )
    d[(52,6)] = ( (0,0,1,-1), )
    
    d[(53,0)] = ( (0,0,0,-1),(0,0,1,-1) )
    d[(53,1)] = ( (0,0,0,-1),(0,0,1,-1) )
    d[(53,2)] = ( (0,0,0,-1),(0,0,1,-1) )
    d[(53,3)] = ( (0,0,0,-1),(1,0,0,-1) )
    d[(53,4)] = ( (0,0,0,-1),(1,0,0,-1) )
    d[(53,5)] = ( (0,0,0,-1),(1,0,0,-1) )
    d[(53,6)] = ( (0,0,0,-1),(0,0,1,-1) )
    
    d[(54,0)] = ( (0,0,0,-1),(0,0,1,-1),(1,0,0,-1) )
    d[(54,1)] = ( (0,0,0,-1),(0,0,1,-1),(1,0,0,-1) )
    d[(54,2)] = ( (0,0,0,-1),(0,0,1,-1),(1,0,0,-1) )
    d[(54,3)] = ( (0,0,0,-1),(1,0,0,-1),(2,0,0,-1) )
    d[(54,4)] = ( (0,0,0,-1),(1,0,0,-1),(2,0,0,-1) )
    d[(54,5)] = ( (0,0,0,-1),(1,0,0,-1),(2,0,0,-1) )
    d[(54,6)] = ( (0,0,0,-1),(0,0,1,-1),(1,0,0,-1) )
    
    d[(55,0)] = ( (0,0,0,-1),(0,0,1,-1),(1,0,0,-1),(1,0,1,-1) )
    d[(55,1)] = ( (0,0,0,-1),(0,0,1,-1),(1,0,0,-1),(1,0,1,-1) )
    d[(55,2)] = ( (0,0,0,-1),(0,0,1,-1),(1,0,0,-1),(1,0,1,-1) )
    d[(55,3)] = ( (0,0,0,-1),(1,0,0,-1),(2,0,0,-1),(3,0,0,-1) )
    d[(55,4)] = ( (0,0,0,-1),(1,0,0,-1),(2,0,0,-1),(3,0,0,-1) )
    d[(55,5)] = ( (0,0,0,-1),(1,0,0,-1),(2,0,0,-1),(3,0,0,-1) )
    d[(55,6)] = ( (0,0,0,-1),(0,0,1,-1),(1,0,0,-1),(1,0,1,-1) )
    
    d[(56,0)] = ( (0,0,0,-1),(0,0,1,-1),(1,0,0,-1),(1,0,1,-1),(2,0,0,-1) )
    d[(56,1)] = ( (0,0,0,-1),(0,0,1,-1),(1,0,0,-1),(1,0,1,-1),(2,0,0,-1) )
    d[(56,2)] = ( (0,0,0,-1),(0,0,1,-1),(1,0,0,-1),(1,0,1,-1),(2,0,0,-1) )
    d[(56,3)] = ( (0,0,0,-1),(1,0,0,-1),(2,0,0,-1),(3,0,0,-1),(4,0,0,-1) )
    d[(56,4)] = ( (0,0,0,-1),(1,0,0,-1),(2,0,0,-1),(3,0,0,-1),(4,0,0,-1) )
    d[(56,5)] = ( (0,0,0,-1),(1,0,0,-1),(2,0,0,-1),(3,0,0,-1),(4,0,0,-1) )
    d[(56,6)] = ( (0,0,0,-1),(0,0,1,-1),(1,0,0,-1),(1,0,1,-1),(2,0,0,-1) )
    
    d[(57,0)] = ( (0,0,0,-1),(0,0,1,-1),(1,0,0,-1),(1,0,1,-1),(2,0,0,-1),(2,0,1,-1) )
    d[(57,1)] = ( (0,0,0,-1),(0,0,1,-1),(1,0,0,-1),(1,0,1,-1),(2,0,0,-1),(2,0,1,-1) )
    d[(57,2)] = ( (0,0,0,-1),(0,0,1,-1),(1,0,0,-1),(1,0,1,-1),(2,0,0,-1),(2,0,1,-1) )
    d[(57,3)] = ( (0,0,0,-1),(1,0,0,-1),(2,0,0,-1),(3,0,0,-1),(4,0,0,-1),(5,0,0,-1) )
    d[(57,4)] = ( (0,0,0,-1),(1,0,0,-1),(2,0,0,-1),(3,0,0,-1),(4,0,0,-1),(5,0,0,-1) )
    d[(57,5)] = ( (0,0,0,-1),(1,0,0,-1),(2,0,0,-1),(3,0,0,-1),(4,0,0,-1),(5,0,0,-1) )
    d[(57,6)] = ( (0,0,0,-1),(0,0,1,-1),(1,0,0,-1),(1,0,1,-1),(2,0,0,-1),(2,0,1,-1) )
    
    d[(58,0)] = (  )
    d[(58,1)] = (  )
    d[(58,2)] = (  )
    d[(58,3)] = (  )
    d[(58,4)] = (  )
    d[(58,5)] = (  )
    d[(58,6)] = (  )
    
    d[(59,0)] = (  )
    d[(59,1)] = (  )
    d[(59,2)] = (  )
    d[(59,3)] = (  )
    d[(59,4)] = (  )
    d[(59,5)] = (  )
    d[(59,6)] = (  )
    
    d[(60,0)] = (  )
    d[(60,1)] = (  )
    d[(60,2)] = (  )
    d[(60,3)] = (  )
    d[(60,4)] = (  )
    d[(60,5)] = (  )
    d[(60,6)] = (  )
    
    d[(61,0)] = (  )
    d[(61,1)] = (  )
    d[(61,2)] = (  )
    d[(61,3)] = (  )
    d[(61,4)] = (  )
    d[(61,5)] = (  )
    d[(61,6)] = (  )
    
    d[(62,0)] = (  )
    d[(62,1)] = (  )
    d[(62,2)] = (  )
    d[(62,3)] = (  )
    d[(62,4)] = (  )
    d[(62,5)] = (  )
    d[(62,6)] = (  )
    
    d[(63,0)] = (  )
    d[(63,1)] = (  )
    d[(63,2)] = (  )
    d[(63,3)] = (  )
    d[(63,4)] = (  )
    d[(63,5)] = (  )
    d[(63,6)] = (  )
    
    return d
</t>
<t tx="michael.20120223085633.1312">def _get_base_config(self, filename):
    file = open(filename, 'r')
    config = dict()
#    print 111
    for line in file:
#        print line
        if len(line) &gt;5 and line[0] != '#' and line[0] != ' ':
            line = line.split()
            config[line[0]] = int(line[1])
    file.close()
    return config
</t>
<t tx="michael.20120223085633.1313">def _get_config(self, filename):
    #filename = self.dir + filename
    config = self._get_base_config(filename)

    config['draw_offset'] = Point(config['draw_offset_x'],config['draw_offset_y'])

    if config['CP_DL_type'] == 0:  #normal CP for DL
        config['N_DL_symb'] = 7
    else:
        config['N_DL_symb'] = 6

    if config['CP_UL_type'] == 0:  #normal CP for UL
        config['N_UL_symb'] = 7
    else:
        config['N_UL_symb'] = 6

    if config['sys_BW'] == 10:
        config['N_DL_RB'] = 50
        config['N_UL_RB'] = 50
    elif config['sys_BW'] == 20:
        config['N_DL_RB'] = 100
        config['N_UL_RB'] = 100

    #DL&amp;UL config
    if config['UL_DL_config'] == 0:
        config['UL_DL_S'] = 'DSUUUDSUUU'
    elif config['UL_DL_config'] == 1:
        config['UL_DL_S'] = 'DSUUDDSUUD'
    elif config['UL_DL_config'] == 2:
        config['UL_DL_S'] = 'DSUDDDSUDD'
    elif config['UL_DL_config'] == 3:
        config['UL_DL_S'] = 'DSUUUDDDDD'
    elif config['UL_DL_config'] == 4:
        config['UL_DL_S'] = 'DSUUDDDDDD'
    elif config['UL_DL_config'] == 5:
        config['UL_DL_S'] = 'DSUDDDDDDD'
    elif config['UL_DL_config'] == 6:
        config['UL_DL_S'] = 'DSUUUDSUUD'

    # cell ID
    config['N_cell_ID'] = 3*config['N_cell_ID_1'] + config['N_cell_ID_2']

    # special subframe
    # calculate how many symbols are there in the DwPTS part of a special subframe
    if config['CP_DL_type'] == 0:
        if config['special_subframe_config'] in (0,5):
            config['DwPTS'] = 3
        elif config['special_subframe_config'] in (1,6):
            config['DwPTS'] = 9
        elif config['special_subframe_config'] in (7,2):
            config['DwPTS'] = 10
        elif config['special_subframe_config'] in (8,3):
            config['DwPTS'] = 11
        elif config['special_subframe_config'] == 4:
            config['DwPTS'] = 12
    else:
        if config['special_subframe_config'] in (0,4):
            config['DwPTS'] = 3
        elif config['special_subframe_config'] in (1,5):
            config['DwPTS'] = 8
        elif config['special_subframe_config'] in (2,6):
            config['DwPTS'] = 9
        elif config['special_subframe_config'] == 3:
            config['DwPTS'] = 10
        
    # calculate how many symbols are there in the UpPTS part of a special subframe
    if config['CP_DL_type'] == 0:
        if config['special_subframe_config'] in (0,1,2,3,4):
            config['UpPTS'] = 1
        elif config['special_subframe_config'] in (5,6,7,8):
            config['UpPTS'] = 2
    else:   # Extended CP
        if config['special_subframe_config'] in (0,1,2,3):
            config['UpPTS'] = 1
        elif config['special_subframe_config'] in (4,5,6):
            config['DwPTS'] = 2

    return config

</t>
<t tx="michael.20120223085633.1321">def add_labels(self):
    # add RB numbers on the left blank of the whole picture.
    penclr = (self.config['color_text_r'],self.config['color_text_b'],self.config['color_text_g'],self.config['color_text_alpha'])
    x = 2
    y = self.config['draw_offset'].y + self.config['RB_height'] * 0.5
    for i in range(self.config['N_DL_RB']):
        self.dc.text( (x,y), str(i), penclr )
        y += self.config['RB_height']
    
    # add slot numbers on the upper blank of the whole picture.
    x = self.config['draw_offset'].x
    y = 2
    for i in range(10*2):
        if self.config['UL_DL_S'][i/2] == 'D':
            length = self.config['DL_RB_width']
        elif self.config['UL_DL_S'][i/2] == 'U':
            length = self.config['UL_RB_width']
        else:	# 'S'
            length = self.config['special_RB_width']
        self.dc.text( (x+0.5*length,y), str(i), penclr )
        x += length
</t>
<t tx="michael.20120223085633.1322">from numpy import floor, ceil
from math import sqrt
#import cPickle

class TDLTE:
    
    def __init__(self, config, re_lattice, re_size_lattice):
        self.config = config
        self.process_config()
        self.re_lattice = re_lattice
        self.re_size_lattice = re_size_lattice
        self.init_PHY_Common()
        
        self._init_re_size_lattice()
        self._init_re_usage_lattice()
        self._init_re_lattice()
        
        # set background for RBs
        self.set_RB_background()
        
        # set DL PHY signals and channels
        self.set_DL_PHY()
        
        # set UL PHY signals and channels
        self.set_UL_PHY()
    
    
    
    @others
</t>
<t tx="michael.20120223085633.1323">def set_RB_background(self):
    
    for sfn in range(self.config['start_SFN'],self.config['start_SFN']+self.config['frame_num']):
        for subframe in range(10):
            if self.config['UL_DL_S'][subframe] == 'D':
                # this is a downlink subframe
                for l in range(2*self.config['N_DL_symb']):
                    for k in range(12*self.config['N_DL_RB']):
                        if (l%(2*self.config['N_DL_symb'])&lt;self.config['N_DL_symb'] and (k/12)%2==0) or (l%(2*self.config['N_DL_symb'])&gt;=self.config['N_DL_symb'] and (k/12)%2==1):
                            self.re_lattice[(sfn,subframe,l,k)] = ( self.config['color_brush1_RB_r'], self.config['color_brush1_RB_g'], self.config['color_brush1_RB_b'], self.config['color_brush1_RB_alpha'] )
            elif self.config['UL_DL_S'][subframe] == 'U':
                # this is a uplink subframe
                for l in range(2*self.config['N_UL_symb']):
                    for k in range(12*self.config['N_UL_RB']):
                        if (l%(2*self.config['N_UL_symb'])&lt;self.config['N_UL_symb'] and (k/12)%2==0) or (l%(2*self.config['N_UL_symb'])&gt;=self.config['N_UL_symb'] and (k/12)%2==1):
                            self.re_lattice[(sfn,subframe,l,k)] = ( self.config['color_brush1_RB_r'], self.config['color_brush1_RB_g'], self.config['color_brush1_RB_b'], self.config['color_brush1_RB_alpha'] )
            else:
                # this is a special subframe
                pass
</t>
<t tx="michael.20120223085633.1327">def ts_to_pixel(self,len_in_ts):
    return round(len_in_ts/(2048+144.)*self.config['cell_width'])
</t>
<t tx="michael.20120223085633.1328">def get_DwPTS_Ts(self):
    DwPTS_Ts = (
        (6592, 19760, 21952, 24144, 26336, 6592, 19760, 21952, 24144),
        (7680, 20480, 23040, 25600, 7680, 20480, 23040)
    )
    return DwPTS_Ts[self.config['CP_DL_type']][self.config['special_subframe_config']]
</t>
<t tx="michael.20120223085633.1329">def get_UpPTS_Ts(self):
    UpPTS_Ts = 0
    if self.config['CP_DL_type'] == 0:
        # normal DL CP
        if self.config['CP_UL_type'] == 0:
            if self.config['special_subframe_config'] in (0,1,2,3,4):
                UpPTS_Ts = 2192
            elif self.config['special_subframe_config'] in (5,6,7,8):
                UpPTS_Ts = 4384
        else:
            if self.config['special_subframe_config'] in (0,1,2,3,4):
                UpPTS_Ts = 2560
            elif self.config['special_subframe_config'] in (5,6,7,8):
                UpPTS_Ts = 5120
    else:
        # extended DL CP
        if self.config['CP_UL_type'] == 0:
            if self.config['special_subframe_config'] in (0,1,2,3):
                UpPTS_Ts = 2192
            elif self.config['special_subframe_config'] in (4,5,6):
                UpPTS_Ts = 4384
        else:
            if self.config['special_subframe_config'] in (0,1,2,3):
                UpPTS_Ts = 2560
            elif self.config['special_subframe_config'] in (4,5,6):
                UpPTS_Ts = 5120
    return UpPTS_Ts
</t>
<t tx="michael.20120223085633.1330">def get_GAP_Ts(self):
    return 30720-self.get_DwPTS_Ts()-self.get_UpPTS_Ts()
</t>
<t tx="michael.20120223085633.1331">def get_DwPTS_symbol_num(self):
    DwPTS_symbol_num = (
        (3, 9, 10, 11, 12, 3, 9, 10, 11),
        (3, 8, 9, 10, 3, 8, 9)
    )
    return DwPTS_symbol_num[self.config['CP_DL_type']][self.config['special_subframe_config']]
</t>
<t tx="michael.20120223085633.1332">def get_UpPTS_symbol_num(self):
    UpPTS_symbol_num = (
        (1,1,1,1,1,2,2,2,2),
        (1,1,1,1,2,2,2)
    )
    return UpPTS_symbol_num[self.config['CP_UL_type']][self.config['special_subframe_config']]
</t>
<t tx="michael.20120223085633.1333">def _draw_lattice(self):
    # initialize pen colors
    penclr_D = ( self.config['color_line_DL_RE_r'], self.config['color_line_DL_RE_g'], self.config['color_line_DL_RE_b'], self.config['color_line_DL_RE_alpha'] )
    penclr_U = ( self.config['color_line_UL_RE_r'], self.config['color_line_UL_RE_g'], self.config['color_line_UL_RE_b'], self.config['color_line_UL_RE_alpha'] )
    penclr_S = ( self.config['color_line_S_RE_r'], self.config['color_line_S_RE_g'], self.config['color_line_S_RE_b'], self.config['color_line_S_RE_alpha'] )
    
    # draw all vertical lines
    start_pos = Point( 0,0 ) + self.config['draw_offset']
    total_width = 0
    total_height = self.config['cell_height']*self.config['N_DL_RB']*12
    for frame in range(self.config['start_SFN'],self.config['start_SFN']+self.config['frame_num']):
        for subframe in range(10):
            if self.config['UL_DL_S'][subframe] == 'D':
                penclr = penclr_D
            elif self.config['UL_DL_S'][subframe] == 'U':
                penclr = penclr_U
            else:
                penclr = penclr_S
            if frame==self.config['start_SFN'] and subframe==0:  # this is not the starting subframe of the first frame
                pass
            else:
                start_pos += Point(1,0)
                total_width += 1
            subframe_start_pos = start_pos
            subframe_width = 0
            line = (start_pos.x,start_pos.y, start_pos.x,start_pos.y+total_height)
            self.dc.line( line, penclr )
            # draw vertical lines
            for l in range(14):
                if self.re_size_lattice.has_key( (frame,subframe,l,0) ):
                    current_symbol_length = round(self.re_size_lattice[(frame,subframe,l,0)][0]/(2048+144.)*self.config['cell_width'])
                    total_width += current_symbol_length
                    subframe_width += current_symbol_length
                    line = (start_pos.x+current_symbol_length,start_pos.y, start_pos.x+current_symbol_length,start_pos.y+total_height)
                    start_pos += Point(current_symbol_length,0)
                    self.dc.line( line, penclr )
            
            # draw horizontal lines for this subframe
            if self.config['UL_DL_S'][subframe] in 'DU':
                for k in range(self.config['N_DL_RB']*12+1):
                    line = (subframe_start_pos.x,subframe_start_pos.y, subframe_start_pos.x+subframe_width,subframe_start_pos.y)
                    subframe_start_pos += Point(0,self.config['cell_height'])
                    self.dc.line( line, penclr )
            else:   # S
                for k in range(self.config['N_DL_RB']*12+1):
                    line = (subframe_start_pos.x,subframe_start_pos.y, subframe_start_pos.x+self.re_size_lattice.DwPTS_width,subframe_start_pos.y)
                    self.dc.line( line, penclr )
                    line = (subframe_start_pos.x+self.re_size_lattice.DwPTS_width+self.re_size_lattice.GAP_width,subframe_start_pos.y, subframe_start_pos.x+subframe_width,subframe_start_pos.y)
                    self.dc.line( line, penclr )
                    subframe_start_pos += Point(0,self.config['cell_height'])
        start_pos += Point(self.config['frame_interval'], 0)
</t>
<t tx="michael.20120223085633.1334">def _draw_REs(self):
    
    start_pos = Point( 0,0 ) + self.config['draw_offset']
    for frame in range(self.config['start_SFN'],self.config['start_SFN']+self.config['frame_num']):
        for subframe in range(10):
            for l in range(7*2):
                if self.re_size_lattice.has_key( (frame,subframe,l,0) ):
                    y = 0
                    width, height = self.re_size_lattice[(frame,subframe,l,0)]
                    width = round(width/(2048+144.)*self.config['cell_width'])
                    for k in range(self.config['N_DL_RB']*12-1,-1,-1):
                        #if self.re_size_lattice.has_key( (frame,subframe,l,k) ):
                        rect = ( start_pos.x+1, start_pos.y+y+1, start_pos.x+width-1, start_pos.y+y+height-1 )
                        self.dc.rectangle( rect, self.re_lattice[(frame,subframe,l,k)] )
                        y += self.re_size_lattice[(frame,subframe,l,k)][1]
                    start_pos += Point(width, 0)
            start_pos += Point(1,0)
        start_pos += Point(self.config['frame_interval'], 0)
                    
</t>
<t tx="michael.20120223085633.1336">@others


def set_DL_PHY(self):
    
    self.REG_nums = dict()
    for frame in range(self.config['start_SFN'],self.config['start_SFN']+self.config['frame_num']):
        for subframe in range(10):
            if self.config['UL_DL_S'][subframe] in 'DS':
                for l in (0,1,2,3):
                    self.REG_nums[(frame,subframe,l)] = self.get_all_REG_in_symbol(frame,subframe,l)
    self.config['REG_nums'] = self.REG_nums
    self.config['REG_indice'] = self.get_REG_indice()
    
    self.set_CSRS_REs()
    self.set_PSS_REs()
    self.set_SSS_REs()
    self.set_PBCH_REs()
    self.set_PCFICH_REs()
    self.set_PHICH_REs()
    
    self.init_REG_dict()
    self.set_PDCCH_REs()
    
    #self.dump_lattice()
</t>
<t tx="michael.20120223085633.1339">@others
</t>
<t tx="michael.20120223085633.1340">"""
Why do we have a argument named force_4_port?

Because even though a system maybe composed of only 2 antenna ports, when we calculate REs occupied by PBCH, 3GPP forces us to take RS of a 4-port system into account.  So this function has such a parameter, which gives it the ability to calculate RS's REs for PBCH.
"""
</t>
<t tx="michael.20120223085633.1341">def get_PSS_REs(self):
    #start_time = time()
    #print 'get_PSS_REs starts'
    REs = list()
    for frame in range(self.config['start_SFN'],self.config['start_SFN']+self.config['frame_num']):
        for subframe in (1,6):
            l = 3-1
            for n in range(-5,67):
                k = n-31 + self.config['N_DL_RB']*self.config['N_RB_sc']/2
                REs.append( (frame,subframe,l,k) )
    #print 'get_PSS_REs ends.  ',time()-start_time
    return tuple(REs)
    
def set_PSS_REs(self):
    self.PSS_REs = self.get_PSS_REs()
    brushclr = (self.config['color_brush_PSS_r'],self.config['color_brush_PSS_g'],self.config['color_brush_PSS_b'],self.config['color_brush_PSS_alpha'])
    for re in self.PSS_REs:
        self.re_lattice[re] = brushclr
        #print re
    #self.dump_lattice()
</t>
<t tx="michael.20120223085633.1342">def get_SSS_REs(self):
    '''
    Return all SSS REs.
    '''
    #start_time = time()
    #print 'get_SSS_REs starts.'
    REs = list()
    for frame in range(self.config['start_SFN'],self.config['start_SFN']+self.config['frame_num']):
        for subframe in (0,5):
            l = self.config['N_DL_symb']-1
            for n in range(-5,67):
                k = n-31 + self.config['N_DL_RB']*self.config['N_RB_sc']/2
                REs.append( (frame,subframe,l+self.config['N_DL_symb'],k) )
    #print 'get_SSS_REs ends.  ',time()-start_time
    return tuple(REs)

def set_SSS_REs(self):
    self.SSS_REs = self.get_SSS_REs()
    brushclr = (self.config['color_brush_SSS_r'],self.config['color_brush_SSS_g'],self.config['color_brush_SSS_b'],self.config['color_brush_SSS_alpha'])
    for re in self.SSS_REs:
        self.re_lattice[re] = brushclr
</t>
<t tx="michael.20120223085633.1343">@others
</t>
<t tx="michael.20120223085633.1344">def get_PBCH_REs(self):
    start_time = time()
    #print 'get_PBCH_REs starts'
    REs = list()
    all_CSRS = self.get_CSRS_AP(0) + self.get_CSRS_AP(1) + self.get_CSRS_AP(2) + self.get_CSRS_AP(3)
    for frame in range(self.config['start_SFN'],self.config['start_SFN']+self.config['frame_num']):
        subframe = 0
        slot = 1
        for l in range(4):
            for k in range(self.config['N_DL_RB']*self.config['N_RB_sc']/2-36,self.config['N_DL_RB']*self.config['N_RB_sc']/2-36+72):
                if (frame,subframe,l+slot*self.config['N_DL_symb'],k) not in all_CSRS:
                    REs.append( (frame,subframe,l+slot*self.config['N_DL_symb'],k) )
    #print 'get_PBCH_REs ends.  ',time()-start_time
    return tuple(REs)

def set_PBCH_REs(self):
    self.PBCH_REs = self.get_PBCH_REs()
    brushclr = (self.config['color_brush_PBCH_r'],self.config['color_brush_PBCH_g'],self.config['color_brush_PBCH_b'],self.config['color_brush_PBCH_alpha'])
    for re in self.PBCH_REs:
        self.re_lattice[re] = brushclr

&lt;&lt; why force_4_port? &gt;&gt;
</t>
<t tx="michael.20120223085633.1345">def get_PCFICH_REs(self):
    from math import floor
    #print 'get_PCFICH_REs starts'
    start_time = time()
    REs = list()
    CSRS = self.CSRS_REs
    for frame in range(self.config['start_SFN'],self.config['start_SFN']+self.config['frame_num']):
        for subframe in range(10):
            if self.config['UL_DL_S'][subframe] == 'D':   # this is a downlink subframe
                l = 0
                k_ = (self.config['N_RB_sc']/2) * (self.config['N_cell_ID'] % (2*self.config['N_DL_RB']))
                for i in range(4):
                    k = k_ + self.config['N_RB_sc']/2* floor(self.config['N_DL_RB']/2.0*i)
                    ks = self.get_REG(l,k)
                    for k in ks:
                        if (frame,subframe,l,k) not in CSRS:
                            REs.append( (frame,subframe,l,int(k)) )
    REs = tuple(REs)
    return REs


def set_PCFICH_REs(self):
    brushclr = (self.config['color_brush_PCFICH_r'],self.config['color_brush_PCFICH_g'],self.config['color_brush_PCFICH_b'],self.config['color_brush_PCFICH_alpha'])
    self.PCFICH_REs = self.get_PCFICH_REs()
    for re in self.PCFICH_REs:
        self.re_lattice[re] = brushclr
</t>
<t tx="michael.20120223085633.1346">@others
</t>
<t tx="michael.20120223085633.1348">def get_REG(self,l,k):
    ks = list()
    if l == 0:
        ks.append(k/6*6)
        ks.append(k/6*6+1)
        ks.append(k/6*6+2)
        ks.append(k/6*6+3)
        ks.append(k/6*6+4)
        ks.append(k/6*6+5)
    elif l == 1:
        if self.config['port_num'] == 2:
            ks.append(k/4*4)
            ks.append(k/4*4+1)
            ks.append(k/4*4+2)
            ks.append(k/4*4+3)
        elif self.config['port_num'] ==4:
            ks.append(k/6*6)
            ks.append(k/6*6+1)
            ks.append(k/6*6+2)
            ks.append(k/6*6+3)
            ks.append(k/6*6+4)
            ks.append(k/6*6+5)
    elif l == 2:
        ks.append(k/4*4)
        ks.append(k/4*4+1)
        ks.append(k/4*4+2)
        ks.append(k/4*4+3)
    elif l == 3:
            if self.config['CP_DL_type'] == 0:    # for nomal CP
                ks.append(k/4*4)
                ks.append(k/4*4+1)
                ks.append(k/4*4+2)
                ks.append(k/4*4+3)
            else:
                ks.append(k/6*6)
                ks.append(k/6*6+1)
                ks.append(k/6*6+2)
                ks.append(k/6*6+3)
                ks.append(k/6*6+4)
                ks.append(k/6*6+5)
    return ks

</t>
<t tx="michael.20120223085633.1386">def how_many_RE_per_REG(self,frame,subframe,l):
    '''
    Return the number of REs per REG in symbol l of (frame, subframe).
    '''
    slot = subframe*2 + l/self.config['N_DL_symb']
    l = l%self.config['N_DL_symb']
    count = 0
    if l == 0:
        count = 6
    elif l == 1:
        if self.config['port_num'] == 2:
            count = 4
        elif self.config['port_num'] ==4:
            count = 6
    elif l == 2:
        count = 4
    elif l == 3:
        if self.config['CP_DL_type'] == 0:    # for nomal CP
            count = 4
        else:
            count = 6
    return count
</t>
<t tx="michael.20120223085633.1390">def REG_index_to_REs(self,frame,subframe,l,REG_index):
    #slot = 2*subframe + l/self.config['N_DL_symb']
    #l = l%self.config['N_DL_symb']
    REs = list()
    count = self.how_many_RE_per_REG(frame,subframe,l)
    csrs = self.CSRS_REs
    for i in range(count):
        if (frame,subframe,l,count*REG_index+i) not in csrs:
            REs.append( (frame,subframe,l,count*REG_index+i) )
    return REs
</t>
<t tx="michael.20120223085633.1392">def get_REG_indice(self):
    start_time = time()
    indice = dict()
    for frame in range(self.config['start_SFN'],self.config['start_SFN']+self.config['frame_num']):
        for subframe in range(10):
            for l in range(3):
                indice[(frame,subframe,l)] = self.get_REG_indice_in_symbol(frame,subframe,l)
	#print 'get_REG_indice consumed: ', time()-start_time
    return indice
</t>
<t tx="michael.20120223085633.1394">def get_REG_indice_in_symbol(self,frame,subframe,l):
    indice = list()
    count = self.how_many_RE_per_REG(frame,subframe,l)
    tmp = 0
    while tmp*count &lt;self.config['N_DL_RB']*self.config['N_RB_sc']:
        indice.append(tmp)
        tmp += 1
    return indice
</t>
<t tx="michael.20120223085633.1396">def RE_to_REG_index(self,re):
    frame,subframe,l,k = re
    count = self.how_many_RE_per_REG(frame,subframe,l)
    return k/count
</t>
<t tx="michael.20120223085633.1398">def set_REG_num(self):
    '''
    This function should be called only once!
    '''
    REG_num = list()
    REG_num.append( 2*self.config['N_DL_RB'] )  # for symbol 0
    if self.config['port_num'] == 2:    # for symbol 1
        REG_num.append( 3*self.config['N_DL_RB'] )
    else:
        REG_num.append( 2*self.config['N_DL_RB'] )
    REG_num.append( 3*self.config['N_DL_RB'] )    # for symbol 2
    if self.config['CP_DL_type'] == 0:    # for symbol 3
        REG_num.append( 3*self.config['N_DL_RB'] )
    else:
        REG_num.append( 2*self.config['N_DL_RB'] )

    return REG_num
</t>
<t tx="michael.20120223085633.1399">def myfloor(self, x):
    x = numpy.floor(x)
    return int(x)

</t>
<t tx="michael.20120223085633.1401">def phich( x, seq_index ):
    # one bit input
    
    # channel coding
    if x == 1:
        x = [1,1,1]
    elif x == 0:
        x = [0,0,0]
    
    # modulation
    for i in range(3):
        if x[i] == 1:
            x[i] = complex( sqrt(2)/2,sqrt(2)/2 )
        elif x[i] == 0:
            x[i] = complex( sqrt(2)/(-2),sqrt(2)/(-2) )
    
    orth_seq = ( (1,1,1,1), (1,-1,1,-1), (1,1,-1,-1), (1,-1,-1,1), (complex(0,1),complex(0,1),complex(0,1),complex(0,1)), (complex(0,1),complex(0,-1),complex(0,1),complex(0,-1)), (complex(0,1),complex(0,1),complex(0,-1),complex(0,-1)), (complex(0,1),complex(0,-1),complex(0,-1),complex(0,1)) )
    d = list()
    for i in range(12):
#        print i%4, i/4
        d.append( x[i/4] * orth_seq[seq_index][i%4] )
    
    # layer mapping
    x = numpy.matrix( '0 0 0 0 0 0; 0 0 0 0 0 0' )
    tmp = x.tolist()
    for i in range(6):
        for j in range(2):
#            print i*2 + j
            tmp[j][i] = d[i*j+j]
    x = tmp
    
    # precoding
    y = numpy.matrix( '0 0 0 0 0 0 0 0 0 0 0 0; 0 0 0 0 0 0 0 0 0 0 0 0' )
    y = y.tolist()
    for i in range(6):
        y[0][2*i] = sqrt(2)/2 * ( real(x[0][i]) + complex(0,1)*complex(0,1)*imag(x[0][i]) )
    for i in range(6):
        y[1][2*i] = sqrt(2)/2 * ( -1*real(x[1][i]) + complex(0,1)*complex(0,1)*imag(x[1][i]) )
    for i in range(6):
        y[0][2*i+1] = sqrt(2)/2 * ( real(x[1][i]) + complex(0,1)*complex(0,1)*imag(x[1][i]) )
    for i in range(6):
        y[1][2*i+1] = sqrt(2)/2 * ( real(x[0][i]) + complex(0,-1)*complex(0,1)*imag(x[0][i]) )
    return y
    
    
    
</t>
<t tx="michael.20120223085633.1404">def set_PHICH_REs(self):
    self.PHICH_REs = self.get_PHICH_REs()
    brushclr = (self.config['color_brush_PHICH_r'],self.config['color_brush_PHICH_g'],self.config['color_brush_PHICH_b'],self.config['color_brush_PHICH_alpha'])
    for re in self.PHICH_REs:
        self.re_lattice[re] = brushclr

def get_PHICH_REs(self):
    #start_time = time()
    #print 'PHICH.get_REs starts.'
    REs = list()
    N_g = (1./6, 1./2, 1, 2)
#    print "N_g is ", N_g[int(self.config['N_g'])]
    N_group_PHICH = int( ceil( N_g[int(self.config['N_g'])] * ( self.config['N_DL_RB']/8. ) ) )
    #print 'in PHICH, befor entering the first for loop.  ',time()-start_time
    for frame in range(self.config['start_SFN'],self.config['start_SFN']+self.config['frame_num']):
        #print 'in PHICH, in the first for loop, frame=%d  '%frame,time()-start_time
        # calculation of m_i, refer to table 6.9-1 in 36.211
        for subframe in range(10):
            if self.config['UL_DL_config'] == 0:
                if subframe in (0,5):
                    m_i = 2
                elif subframe in (1,6):
                    m_i = 1
                else:
                    m_i = 0
            elif self.config['UL_DL_config'] == 1:
                if subframe in (1,4,6,9):
                    m_i = 1
                else:
                    m_i = 0
            elif self.config['UL_DL_config'] == 2:
                if subframe in (3,8):
                    m_i = 1
                else:
                    m_i = 0
            elif self.config['UL_DL_config'] == 3:
                if subframe in (0,8,9):
                    m_i = 1
                else:
                    m_i = 0
            elif self.config['UL_DL_config'] == 4:
                if subframe in (8,9):
                    m_i = 1
                else:
                    m_i = 0
            elif self.config['UL_DL_config'] == 5:
                if subframe == 8:
                    m_i = 1
                else:
                    m_i = 0
            elif self.config['UL_DL_config'] == 6:
                if subframe in (0,1,5,6,9):
                    m_i = 1
                else:
                    m_i = 0
            slot = 0
            for l_ in range(self.config['CFI']):
                n_l = len( self.config['REG_indice'][(frame,subframe,l_)] )
#                print l,n_l
#                print m_i,N_group_PHICH
                for m in range( m_i*N_group_PHICH ):
#                    print m,
                    for i in (0,1,2):
                        if self.config['PHICH_duration'] == 0:
                            l = 0
                        elif self.config['PHICH_duration'] == 1 and subframe in (1,6):
                            l = ( 1 + i + int(floor(m/2.)) ) % 2
                        else:
                            l = i
                        n_cur = len( self.config['REG_indice'][(frame,subframe,l)] )
                        n_0 = len( self.config['REG_indice'][(frame,subframe,0)] )
                        n_1 = len( self.config['REG_indice'][(frame,subframe,1)] )
                        if self.config['PHICH_duration'] == 1 and subframe in (1,6):
                            if i == 0:
                                n = floor(self.config['N_cell_ID'] * n_cur / n_0 + m) % n_cur
                            elif i == 1:
                                n = floor(self.config['N_cell_ID'] * n_cur / n_0 + m + floor(n_cur/3.)) % n_cur
                            elif i == 2:
                                n = floor(self.config['N_cell_ID'] * n_cur / n_0 + m + floor(2*n_cur/3.)) % n_cur
                        else:
                            if i == 0:
                                n = floor(self.config['N_cell_ID'] * n_cur / n_0 + m) % n_cur
                            elif i == 1:
                                n = floor(self.config['N_cell_ID'] * n_cur / n_0 + m + floor(n_cur/3.)) % n_cur
                            elif i == 2:
                                n = floor(self.config['N_cell_ID'] * n_cur / n_0 + m + floor(2*n_cur/3.)) % n_cur
                        n = int(n)
                        res = self.REG_index_to_REs(frame,subframe,l,self.config['REG_indice'][(frame,subframe,l)][n])
                        for re in res:
                            REs.append(re)
    
    REG_indice = dict()
    #print 'in PHICH, print 2:  ',time()-start_time
    for re in REs:
        frame,subframe,l,k = re
        if (frame,subframe,l) not in REG_indice.keys():
            REG_indice[(frame,subframe,l)] = list()
            REG_indice[(frame,subframe,l)].append( self.RE_to_REG_index(re) )
        else:
            tmp_REG_index = self.RE_to_REG_index(re)
            if tmp_REG_index not in REG_indice[(frame,subframe,l)]:
                REG_indice[(frame,subframe,l)].append( tmp_REG_index )
    for key in REG_indice.keys():
        for index in REG_indice[key]:
            self.config['REG_indice'][key].remove(index)
    #print 'PHICH.get_REs ends.  ',time()-start_time
    return tuple(REs)
    


</t>
<t tx="michael.20120223085633.1405">def set_PDCCH_REs(self):
    brushclr = (self.config['color_brush_PDCCH_r'],self.config['color_brush_PDCCH_g'],self.config['color_brush_PDCCH_b'],self.config['color_brush_PDCCH_alpha'])
    for re in self.get_PDCCH_REs():
        self.re_lattice[re] = brushclr

def get_PDCCH_REs(self):
    start_time = time()
    #print 'get_PDCCH_REs starts.'
    REs = tuple()
    for frame in range(self.config['start_SFN'],self.config['start_SFN']+self.config['frame_num']):
        for subframe in range(10):
            if self.config['UL_DL_S'][subframe] in 'DS':
                #print frame,subframe
                for reg in self.REG_dict[(frame,subframe)]:
                    REs = REs + reg
#    print self.config['REG_indice'][(0,0,0)]
    #print 'get_PDCCH_REs ends.  ',time()-start_time
    return REs

@others
</t>
<t tx="michael.20120223085633.1406">def set_PRACH_REs(self):
    brushclr = (self.config['color_brush_PRACH_r'],self.config['color_brush_PRACH_g'],self.config['color_brush_PRACH_b'],self.config['color_brush_PRACH_alpha'])
    for re in self.get_PRACH_REs():
        self.re_lattice[re] = brushclr

def get_PRACH_REs(self):
    start_time = time()
    #print 'PRACH.get_REs starts'
    REs = []
    n_RA_PRBoffset = self.config['n_RA_PRBoffset']
    PRACH_Configuration_Index = self.config['PRACH_Configuration_Index']
    UL_DL_config = self.config['UL_DL_config']
    prach_resource = self.config['RA_PREAMBLE_MAPPING'][(PRACH_Configuration_Index,UL_DL_config)]
    N_UL_RB = self.config['N_UL_RB']
    #for each four-element tuple
    for (f_RA, t_0_RA, t_1_RA, t_2_RA) in prach_resource:
        frames = list()
        for f in range(self.config['start_SFN'], self.config['start_SFN']+self.config['frame_num']):
            if t_0_RA == 0:
                frames.append(f)
            elif t_0_RA == 1 and f%2==0:
                frames.append(f)
            elif t_0_RA == 2 and f%2==1:
                frames.append(f)
        #print frames

        if self.config['Preamble_Format'] !=4:
            subframe = t_1_RA*5 + self.config['UL_DL_S'][t_1_RA*5:].find('U') + t_2_RA
            if f_RA %2 == 0:
                n_RA_PRB = n_RA_PRBoffset + 6*floor(f_RA/2.)
            else:
                n_RA_PRB = N_UL_RB -6 -n_RA_PRBoffset -6*floor(f_RA/2.)
        else:   # format 4
            subframe = t_1_RA*5 + self.config['UL_DL_S'][t_1_RA*5:].find('S')
        
        #print frames,slots,n_RA_PRB

        for frame in frames:
            if self.config['Preamble_Format'] in (0,1,2,3):
                for l in range(self.config['N_UL_symb']*2): #for PRACH format 0-3, a whole RG pair is allocated
                    for k in range(self.config['N_RB_sc']*6):   # always 6 RBs in frequency domain
                        REs.append( (frame,subframe,l,k+n_RA_PRB*self.config['N_RB_sc']) )
            else: # format 4
                n_f = frame
                N_SP = self.config['UL_DL_S'].count('S')
                if ((n_f%2)*(2-N_SP)+t_1_RA) %2==0:
                    n_RA_PRB = 6*f_RA
                else:
                    n_RA_PRB = self.config['N_UL_RB'] - 6*(f_RA+1)
                for l in range(self.config['DwPTS']+1,self.config['DwPTS']+self.config['UpPTS']+1):
                    for k in range(self.config['N_RB_sc']*6):
                        REs.append( (frame,subframe,l,k+n_RA_PRB*self.config['N_RB_sc']) )
    #print REs
    #print 'PRACH.get_REs ends.  ',time()-start_time
    return tuple(REs)

</t>
<t tx="michael.20120223085633.1407">@others

def set_UL_PHY(self):
    
    self.set_PRACH_REs()
</t>
<t tx="michael.20120223085633.1409">def init_REG_tables(self):
    self.init_REG_RE2index_in_symbol()
    self.init_REG_RE2index_in_subframe()



def init_REG_RE2index_in_symbol(self):
    pass


def init_REG_RE2index_in_subframe(self):
    pass
</t>
<t tx="michael.20120226084901.1395">def validate_config(self):
    '''
    Valicate configuration. This method should be called after config has been read in from the file.
    '''
    
    if len(self.config['RA_PREAMBLE_MAPPING'][self.config['PRACH_Configuration_Index'],self.config['UL_DL_config']])==0:
        print "PRACH configuration is wrong!"
</t>
<t tx="michael.20120226084901.1590">def _draw_legend(self):
    
    font = self.dc.getfont()
    legend_config = list()
    channel_list = ('CSRS_AP0','CSRS_AP1','CSRS_AP2','CSRS_AP3','PBCH','PSS','SSS','PCFICH','PHICH','PDCCH','PRACH')
    for channel_name in channel_list:
        r = self.config['color_brush_'+channel_name+'_r']
        g = self.config['color_brush_'+channel_name+'_g']
        b = self.config['color_brush_'+channel_name+'_b']
        alpha = self.config['color_brush_'+channel_name+'_alpha']
        legend_config.append( (channel_name, (r,g,b,alpha)) )
    max_length = 0
    for channel_name in channel_list:
        if len(channel_name) &gt; max_length:
            max_length = len(channel_name)
    text_width, text_height = font.getsize('A'*max_length)
    pic_width, pic_height = text_width, text_height
    h_gap, v_gap = 7, 3
    #image = Image.new("RGBA", (h_gap*3+text_width+pic_width, h_gap*(len(channel_list)+1) + text_height*len(channel_list)) )
    #dc = ImageDraw.Draw(image)
    
    
    font_color = (0,0,0)
    start_x, start_y = self.config['draw_offset_x']+40, self.config['lattice_height']+self.config['draw_offset_y']+(self.config['image_height']-self.config['lattice_height'])/6
    
    count = 0
    for channel_name, color in legend_config:
        if count&lt;len(channel_list)/2:
            x = count*(h_gap+text_width+pic_width)
            y = 0
        else:
            x = (count-len(channel_list)/2)*(h_gap+text_width+pic_width)
            y = v_gap + text_height
        self.dc.text( (start_x+x, start_y+y), channel_name, font_color )
        self.dc.rectangle( (start_x+x+text_width+1, start_y+y, start_x+x+text_width+pic_width+1, start_y+y+pic_height), color )
        count += 1

    #image.save("LTE_Legend.png")
</t>
<t tx="michael.20120226084901.1591">def init_PHY_Common(self):    
    self.init_BPSK()
    self.init_QPSK()
    self.init_16QAM()
    self.init_64QAM()

@others
</t>
<t tx="michael.20120226084901.1592">def c(self, c_init, i):
    N_C = 1600
    return (self.x_1(i+N_C) + self.x_2(c_init,i+N_C)) %2
</t>
<t tx="michael.20120226084901.1593">def BPSK(self, b):
    # one bit modulation
    return self.BPSK[b]

def init_BPSK(self):
    self.BPSK = ( complex( 1/sqrt(2), 1/sqrt(2) ), complex( -1/sqrt(2), -1/sqrt(2) ) )
</t>
<t tx="michael.20120226084901.1594">def QPSK(self, (b0,b1)):
    return self.QPSK[2*b0+b1]

def init_QPSK(self):
    self.QPSK = ( complex(1/sqrt(2),1/sqrt(2)), complex(1/sqrt(2),-1/sqrt(2)),
                        complex(-1/sqrt(2),1/sqrt(2)), complex(-1/sqrt(2),-1/sqrt(2))
    )
</t>
<t tx="michael.20120226084901.1595">def QAM16(self, (b0,b1,b2,b3)):
    return self.QAM16[b3+2*b2+4*b1+8*b0]

def init_16QAM(self):
    I = Q = 1/sqrt(10)
    self.QAM16 = (  complex(1*I, 1*Q),
                            complex(1*I, 3*Q),
                            complex(3*I, 1*Q),
                            complex(3*I, 3*Q),
                            complex(1*I, -1*Q),
                            complex(1*I, -3*Q),
                            complex(3*I, -1*Q),
                            complex(3*I, -3*Q),
                            complex(-1*I, 1*Q),
                            complex(-1*I,3*Q),
                            complex(-3*I, 1*Q),
                            complex(-3*I, 3*Q),
                            complex(-1*I, -1*Q),
                            complex(1*I, -3*Q),
                            complex(-3*I, -1*Q),
                            complex(-3*I, -3*Q),
    )
</t>
<t tx="michael.20120226084901.1596">def QAM64(self, (b0,b1,b2,b3,b4,b5)):
    return self.QAM64[b5+b4*2+b3*4+b2*8+b1*16+b0*32]


def init_64QAM(self):
    tmp_64QAM = [0] * 64
    I = Q = 1/sqrt(42)
    tmp_list = (    (3,3), (3,1), (1,3), (1,1), (3,5), (3,7), (1,5), (1,7),
                        (5,3), (5,1), (7,3), (7,1), (5,5), (5,7), (7,5), (7,7),
                        (3,-3), (3,-1), (1,-3), (1,-1), (3,-5), (3,-7), (1,-5),(1,-7),
                        (5,-3), (5,-1), (7,-3), (7,-1), (5,-5), (5,-7), (7,-5), (7,-7),
                        (-3,3), (-3,1), (-1,3), (-1,1), (-3,5), (-3,7), (-1,5), (-1,7),
                        (-5,3), (-5,1), (-7,3), (-7,1), (-5,5), (-5,7), (-7,5), (-7,7),
                        (-3,-3), (-3,-1), (-1,-3),(-1,-1), (-3,-5), (-3,-7), (-1,-5), (-1,-7),
                        (-5,-3), (-5,-1), (-7,-3), (-7,-1), (-5,-5), (-5,-7), (-7,-5), (-7,-7) )
    for k in range(len(tmp_list)):
        i,q = tmp_list[k]
        tmp_64QAM[k] = complex( i*I, q*Q )
    self.QAM64 = tuple(tmp_64QAM)
</t>
<t tx="michael.20120226084901.1597">def x_1(self, i):
    x1_init = 1
    while i&gt;30:
        tmp = (x1_init&amp;1 ^ x1_init&amp;8)%2
        x1_init = x1_init&gt;&gt;1 ^ tmp*(2**30)
        i -= 1
    return (x1_init &gt;&gt; i) &amp; 1

</t>
<t tx="michael.20120226084901.1598">def x_2(self, c_init, i):
    while i&gt;30:
        tmp = (c_init&amp;1 ^ c_init&amp;2 ^ c_init&amp;4 ^ c_init&amp;8)%2
        c_init = c_init&gt;&gt;1 ^ tmp*(2**30)
        i -= 1
    return (c_init &gt;&gt; i) &amp; 1

</t>
<t tx="michael.20120227090153.1248">def get_PDCCH_common_search_space(self, L, N_CCE_k):
    Y_k = 0
    if L ==4 :
        M_L = 4
    elif L == 8:
        M_L = 2
    CCE_indices = list()
    for i in range(L):
        for m in range(M_L):
            CCE_indices.append( L*((Y_k+m)%(N_CCE_k/L))+i )
    CCE_indices.sort()
    return tuple(CCE_indices)

def get_PDCCH_UE_specific_search_space(self, n_s, n_RNTI, L, N_CCE_k):
    A = 39827
    D = 65537
    k = n_s/2
    Y_k = self.Y_sequence(n_RNTI,k)
    if L in (1,2):
        M_L = 6
    elif L in (4,8):
        M_L = 2
    CCE_indices = list()
    for m in range(M_L):
        for i in range(L):
            CCE_indices.append( L*((Y_k+m)%(N_CCE_k/L))+i )
    CCE_indices.sort()
    return tuple(CCE_indices)
    
def Y_sequence(self, n_RNTI, k):
    # if n_RNTI==0, a error should be raised
    D = 65537
    A = 39827
    if k == -1:
        return n_RNTI
    else:
        return (A*self.Y_sequence(n_RNTI,k-1)) % D
</t>
<t tx="michael.20120227090153.1249">def _draw_mark(self):
    font = self.dc.getfont()
    author = "Author: Ling Duo, Email: duo.ling.cn@gmail.com"
    project = "http://code.google.com/p/lte-phy-channel-on-air/"
    r, g, b, alpha = 0, 0, 0, 128
    text_width, text_height = font.getsize('A'*len(author))
    pic_width, pic_height = text_width, text_height
    font_color = (0,0,0)
    start_x, start_y = self.config['draw_offset_x']+self.config['image_width']/3*2, self.config['lattice_height']+self.config['draw_offset_y']+(self.config['image_height']-self.config['lattice_height'])/6
    self.dc.text( (start_x, start_y), author, font_color )
    start_y += text_height+5
    self.dc.text( (start_x, start_y), project, font_color )

</t>
<t tx="michael.20120301114815.1252">@others
</t>
<t tx="michael.20120301114815.1253">def validate_config(self):
    pass
</t>
<t tx="michael.20120301114815.1254">def process_config(self):
    
    # CFI_sequence
    self.config['CFIs'] = [0] * 10
    self.config['CFIs'][9] = int(self.config['CFI_sequence']%10)
    for subframe in range(1, 10):
        self.config['CFIs'][9-subframe] = int(self.config['CFI_sequence']/(10**subframe) % 10)
    self.config['CFIs'] = tuple(self.config['CFIs'])
</t>
<t tx="michael.20120301114815.1256">def get_all_REG_in_symbol(self,frame,subframe,l):

    REGs = list()
    if l == 0:
        for k in range( self.config['N_DL_RB']*self.config['N_RB_sc']/6 ):
            REGs.append( (frame,subframe,l,6*k) )
            REGs.append( (frame,subframe,l,6*k+1) )
            REGs.append( (frame,subframe,l,6*k+2) )
            REGs.append( (frame,subframe,l,6*k+3) )
            REGs.append( (frame,subframe,l,6*k+4) )
            REGs.append( (frame,subframe,l,6*k+5) )
    elif l == 1:
        if self.config['port_num'] == 2:
            for k in range( self.config['N_DL_RB']*self.config['N_RB_sc']/4 ):
                REGs.append( (frame,subframe,l,6*k) )
                REGs.append( (frame,subframe,l,6*k+1) )
                REGs.append( (frame,subframe,l,6*k+2) )
                REGs.append( (frame,subframe,l,6*k+3) )
        elif self.config['port_num'] ==4:
            for k in range( self.config['N_DL_RB']*self.config['N_RB_sc']/6 ):
                REGs.append( (frame,subframe,l,6*k) )
                REGs.append( (frame,subframe,l,6*k+1) )
                REGs.append( (frame,subframe,l,6*k+2) )
                REGs.append( (frame,subframe,l,6*k+3) )
                REGs.append( (frame,subframe,l,6*k+4) )
                REGs.append( (frame,subframe,l,6*k+5) )
    elif l == 2:
        for k in range( self.config['N_DL_RB']*self.config['N_RB_sc']/4 ):
            REGs.append( (frame,subframe,l,6*k) )
            REGs.append( (frame,subframe,l,6*k+1) )
            REGs.append( (frame,subframe,l,6*k+2) )
            REGs.append( (frame,subframe,l,6*k+3) )
    elif l == 3:
            if self.config['CP_DL_type'] == 0:    # for nomal CP
                for k in range( self.config['N_DL_RB']*self.config['N_RB_sc']/4 ):
                    REGs.append( (frame,subframe,l,6*k) )
                    REGs.append( (frame,subframe,l,6*k+1) )
                    REGs.append( (frame,subframe,l,6*k+2) )
                    REGs.append( (frame,subframe,l,6*k+3) )
            else:
                for k in range( self.config['N_DL_RB']*self.config['N_RB_sc']/6 ):
                    REGs.append( (frame,subframe,l,6*k) )
                    REGs.append( (frame,subframe,l,6*k+1) )
                    REGs.append( (frame,subframe,l,6*k+2) )
                    REGs.append( (frame,subframe,l,6*k+3) )
                    REGs.append( (frame,subframe,l,6*k+4) )
                    REGs.append( (frame,subframe,l,6*k+5) )

    return tuple(REGs)




</t>
<t tx="michael.20120301114815.1257">@others

</t>
<t tx="michael.20120301114815.1258">def get_REGs_for_subframe(self, frame, subframe):
    '''Note: this method should be called after CSRS, PCFICH, and PHICH REs have been calculated.
    initialize two dicts
        REGs: REG_index =&gt; REs
    '''
    REGs = list()
    CFI = self.config['CFIs'][subframe]
    sc_num = self.config['N_DL_RB']*self.config['N_RB_sc']
    if self.config['UL_DL_S'][subframe] in 'DS':
        k_count = [0] * CFI
        l = 0
        while min(k_count) &lt;sc_num:
            if min(k_count) == k_count[l]:
                # chance for this symbol to get a REG
                re_count = 0
                reg = [0]*4
                k = k_count[l]
                while re_count&lt;4 and k&lt;=sc_num:
                    re = (frame,subframe,l,k)
                    if (re in self.CSRS_REs) or (re in self.PCFICH_REs) or (re in self.PHICH_REs) or (re in self.PSS_REs):
                        pass
                    else:   # this RE isn't used by anyone
                        reg[re_count] = re
                        re_count += 1
                    k += 1
                if re_count == 4:
                    re_count = 0
                    REGs.append(tuple(reg))
                    k_count[l] = k
            l = (l+1)%CFI
    return tuple(REGs)
</t>
<t tx="michael.20120301114815.1379">def init_REG_dict(self):
    
    self.REG_dict = dict()
    for frame in range(self.config['start_SFN'],self.config['start_SFN']+self.config['frame_num']):
        for subframe in range(10):
            if self.config['UL_DL_S'][subframe] in 'DS':
                self.REG_dict[(frame,subframe)] = self.get_REGs_for_subframe(frame,subframe)
</t>
<t tx="michael.20120301114815.1381">def dump_lattice(self):
    start_time = time()
    # dump self.re_size_lattice
    f = open("re_size_lattice.txt",'w')
    for sfn in range(self.config['start_SFN'],self.config['start_SFN']+self.config['frame_num']):
        for subframe in range(10):
            for l in range(2*self.config['N_DL_symb']):
                for k in range(12*self.config['N_DL_RB']):
                    if self.re_size_lattice.has_key( (sfn,subframe,l,k) ):
                        f.write( str((sfn,subframe,l,k)) + ':' + str(self.re_size_lattice[(sfn,subframe,l,k)]) )
                        f.write('\t')
            f.write('\n')
    f.close()
    
    # dump self.re_lattice
    f = open("re_lattice.txt",'w')
    for sfn in range(self.config['start_SFN'],self.config['start_SFN']+self.config['frame_num']):
        for subframe in range(10):
            for l in range(2*self.config['N_DL_symb']):
                for k in range(12*self.config['N_DL_RB']):
                    if self.re_lattice.has_key( (sfn,subframe,l,k) ):
                        f.write( str((sfn,subframe,l,k)) + ':' + str(self.re_lattice[(sfn,subframe,l,k)]) )
                        f.write('\t')
            f.write('\n')
    f.close()
    print 'dump_lattice consumed: ', time()-start_time
</t>
<t tx="michael.20120301114815.1382">def _init_re_usage_lattice(self):
    '''
    A bitwise interpretated integer:
        default: all 0 =&gt; blank
        bit0:   1 for CSRS
        bit2-1: Antenna Port Number
        bit3:   1 for PSS
        bit4:   1 for SSS
        bit5:   1 for PBCH
        bit6:   1 for PCFICH
        bit7:   1 for PHICH
        bit8:   1 for PDCCH
        bit16-9:    CCE index (8 bit)
        bit26-17:   REG index (10 bit)
        bit27:   1 for PRACH
    '''
    self.re_usage_lattice = RELattice()
    
    # constants
    self.RE_USAGE_BLANK = 0
    self.RE_USAGE_CSRS = 1
    self.RE_USAGE_PSS = 1&gt;&gt;3
    self.RE_USAGE_SSS = 1&gt;&gt;4
    self.RE_USAGE_PBCH = 1&gt;&gt;5
    self.RE_USAGE_PCFICH = 1&gt;&gt;6
    self.RE_USAGE_PHICH = 1&gt;&gt;7
    self.RE_USAGE_PDCCH = 1&gt;&gt;8
    
    # initialize RE usage lattice
    for k in self.re_size_lattice.keys():
        self.re_usage_lattice[k] = self.RE_USAGE_BLANK

def re_set_CSRS_AP(self, ap_num):
    return 1 ^ ap_num&lt;&lt;1

def re_get_CSRS_AP(self, x):
    return (x&gt;&gt;1)&amp;3

def re_set_CCE_index(self, x, cce_index):
    return x ^ cce_index&lt;&lt;9

def re_set_REG_index(self, x, reg_index):
    return x ^ reg_index&lt;&lt;17

def re_get_PDCCH_CCE_index(self, x):
    return (x&gt;&gt;9)&amp;255

def re_get_PDCCH_REG_index(self, x):
    return (x&gt;&gt;17)&amp;1023

def re_is_blank(self, x):
    return x==0

def re_is_CSRS(self, x):
    return bool(x &amp; 1)

def re_is_PSS(self, x):
    return bool( (x&gt;&gt;3)&amp;1 )
    
def re_is_SSS(self, x):
    return bool( (x&gt;&gt;4)&amp;1 )

def re_is_PBCH(self, x):
    return bool( (x&gt;&gt;5)&amp;1 )

def re_is_PCFICH(self, x):
    return bool( (x&gt;&gt;6)&amp;1 )

def re_is_PHICH(self, x):
    return bool( (x&gt;&gt;7)&amp;1 )

def re_is_PDCCH(self, x):
    return bool( (x&gt;&gt;8)&amp;1 )

def re_is_PRACH(self, x):
    return bool( (x&gt;&gt;27)&amp;1 )
</t>
<t tx="michael.20120301114815.1384">def _init_re_size_lattice(self):
    for sfn in range(self.config['start_SFN'],self.config['start_SFN']+self.config['frame_num']):
        for subframe in range(10):
            if self.config['UL_DL_S'][subframe] == 'D':
                # this is a downlink subframe
                for l in range(2*self.config['N_DL_symb']):
                    for k in range(12*self.config['N_DL_RB']):
                        if self.config['CP_DL_type'] == 0:
                            # normal CP
                            if l==0:
                                width = 160+2048
                            else:
                                width = 144+2048
                        else:
                            # extended CP
                            width = 512+2048
                        self.re_size_lattice[(sfn,subframe,l,k)] = (width,self.config['cell_height'])
            elif self.config['UL_DL_S'][subframe] == 'U':
                # this is a uplink subframe
                for l in range(2*self.config['N_UL_symb']):
                    for k in range(12*self.config['N_UL_RB']):
                        if self.config['CP_UL_type'] == 0:
                            # normal CP
                            if l==0:
                                width = 160+2048
                            else:
                                width = 144+2048
                        else:
                            # extended CP
                            width = 512+2048
                        self.re_size_lattice[(sfn,subframe,l,k)] = (width,self.config['cell_height'])
            else:   # S
                # this is a special subframe
                # this is tricky, and here we treat the GAP as one symbol
                # DwPTS
                for k in range(12*self.config['N_DL_RB']):
                    if self.config['CP_DL_type'] == 0:
                            # normal CP in DL
                            # set DL symbols
                            self.re_size_lattice[(sfn,subframe,0,k)] = (160+2048,self.config['cell_height'])
                            for l in range(1,self.get_DwPTS_symbol_num()):
                                self.re_size_lattice[(sfn,subframe,l,k)] = (144+2048,self.config['cell_height'])
                    else:
                        # extended CP in DL
                        # set DL symbols
                        for l in range(self.get_DwPTS_symbol_num()):
                            self.re_size_lattice[(sfn,subframe,l,k)] = (512+2048,self.config['cell_height'])
                # GAP
                for k in range(12*self.config['N_DL_RB']):
                    self.re_size_lattice[(sfn,subframe,self.get_DwPTS_symbol_num(),k)] = (self.get_GAP_Ts(),self.config['cell_height'])
                # UpPTS
                for k in range(12*self.config['N_DL_RB']):
                    if self.config['CP_UL_type'] == 0:
                        # normal CP in UL
                        for l in range(self.get_UpPTS_symbol_num()):
                            self.re_size_lattice[(sfn,subframe,l+self.get_DwPTS_symbol_num()+1,k)] = (144+2048,self.config['cell_height'])
                    else:
                        # extended CP in UL
                        for l in range(self.get_UpPTS_symbol_num()):
                            self.re_size_lattice[(sfn,subframe,l+self.get_DwPTS_symbol_num()+1,k)] = (512+2048,self.config['cell_height'])
    
    self.re_size_lattice.DwPTS_width = self.ts_to_pixel(self.get_DwPTS_Ts())
    self.re_size_lattice.GAP_width = self.ts_to_pixel(self.get_GAP_Ts())
    self.re_size_lattice.UpPTS_width = self.ts_to_pixel(self.get_UpPTS_Ts())
</t>
<t tx="michael.20120301114815.1385">def _init_re_lattice(self):
    color = (self.config['color_brush_RE_r'], self.config['color_brush_RE_g'], self.config['color_brush_RE_b'], self.config['color_brush_RE_alpha'])
    s_color = (self.config['color_brush_S_RE_r'], self.config['color_brush_S_RE_g'], self.config['color_brush_S_RE_b'], self.config['color_brush_S_RE_alpha'])
    for k in self.re_size_lattice.keys():
        if self.config['UL_DL_S'][k[1]] == 'S':
            self.re_lattice[k] = s_color
        else:
            self.re_lattice[k] = color
</t>
<t tx="michael.20120301114815.1386">def get_CSRS_AP(self, p):
    #start_time = time()
    #print 'get_CSRS_AP starts.'

    REs = list()
    v_shift = self.config['N_cell_ID'] % 6
    for frame in range(self.config['start_SFN'],self.config['start_SFN']+self.config['frame_num']):
        for subframe in range(10):
            if self.config['UL_DL_S'][subframe] == 'D':
                for slot in (0,1):
                    n_s = 2*subframe + slot
                    if p in (0,1):
                        ls = (0,self.config['N_DL_symb']-3)
                    else:
                        ls = (1,)
                    for l in ls:
                        if (p==0 and l==0) or (p==1 and l!=0):
                            v = 0
                        elif (p==0 and l!=0) or (p==1 and l==0):
                            v = 3
                        elif p==2:
                            v = 3 * (n_s%2)
                        elif p==3:
                            v = 3 + 3*(n_s%2)
                        for m in range(2*self.config['N_DL_RB']):
                            k = 6*m + (v+v_shift)%6
                            REs.append( (frame,subframe,l+self.config['N_DL_symb']*slot,k) )
            elif self.config['UL_DL_S'][subframe] == 'S':
                if self.config['DwPTS'] &gt; self.config['N_DL_symb']:
                    slot_num = 2
                else:
                    slot_num = 1
                for slot in range(slot_num):
                    n_s = 2*subframe + slot
                    if p in (0,1):
                        ls = (0,self.config['N_DL_symb']-3)
                    else:
                        ls = (1,)
                    for l in ls:
                        if (p==0 and l==0) or (p==1 and l!=0):
                            v = 0
                        elif (p==0 and l!=0) or (p==1 and l==0):
                            v = 3
                        elif p==2:
                            v = 3 * (n_s%2)
                        elif p==3:
                            v = 3 + 3*(n_s%2)
                        for m in range(2*self.config['N_DL_RB']):
                            k = 6*m + (v+v_shift)%6
                            if l &lt; self.config['DwPTS'] - self.config['N_DL_symb']*slot:
                                #self.re_usage_lattice[(frame,subframe,l+self.config['N_DL_symb']*slot,k)] = self.re_set_CSRS_AP(p)
                                REs.append( (frame,subframe,l+self.config['N_DL_symb']*slot,k) )
    #print 'get_CSRS_AP ends.  ',time()-start_time
    return tuple(REs)
</t>
<t tx="michael.20120301114815.1387">def set_CSRS_REs(self):
    for ap in range(self.config['port_num']):
        brushclr = (self.config['color_brush_CSRS_AP'+str(ap)+'_r'], self.config['color_brush_CSRS_AP'+str(ap)+'_g'], self.config['color_brush_CSRS_AP'+str(ap)+'_b'], self.config['color_brush_CSRS_AP'+str(ap)+'_alpha'])
        for re in self.get_CSRS_AP(ap):
            self.re_lattice[re] = brushclr
    CSRS_REs = tuple()
    for ap in range(self.config['port_num']):
        CSRS_REs = CSRS_REs + self.get_CSRS_AP(ap)
    self.CSRS_REs = CSRS_REs
</t>
<t tx="michael.20120301114815.1390">def channel_code_HI(self, HI):
    return ((0,0,0),(1,1,1))[HI]

def phich(self, HI, n_s, n_group_PHICH, n_seq_PHICH):
    # one bit input: 1 for ACK, 0 for NACK
    
    # channel coding
    b = self.channel_code_HI(HI)
    M_bit = M_s = 3
    
    # modulation
    z = [0] * M_s
    for i in range(M_bit):
        z[i] = self.BPSK(b[i])
    
    if self.config['CP_DL_type'] == 0:
        N_PHICH_SF = 4  # for normal CP
    else:
        N_PHICH_SF = 2  # for extended CP
    
    # 8 orthorgonal sequences for normal CP
    orth_seq_NCP = ( (+1,+1,+1,+1),  (+1,-1,+1,-1),    (+1,+1,-1,-1),    (+1,-1,-1,+1),
                                 (+j,+j,+j,+j), (+j,-j,+j,-j),  (+j,+j,-j,-j),  (+j,-j,-j,+j) )
    # 4 orthorgonal sequences for extended CP
    orth_seq_ECP = ( (+1,+1),    (+1,-1),    (+j,+j),    (+j,-j) )
    
    # bit-wise multiplied with an orthogonal sequence (should be scrambled, but not implemented here)
    M_symb = N_PHICH_SF * M_s
    d = [0] * M_symb
    c_init = (n_s/2+1) * (2*self.config['N_cell_ID']+1)* 2**9 + self.config['N_cell_ID']
    for i in range(M_symb):
        d[i] = orth_seq[n_seq_PHICH][i%N_PHICH_SF] * (1-2*self.c(c_init,i)) * z[i/4]
    
    # REG alignment
    if self.config['CP_DL_type'] == 0:
        d_0 = d  # for normal CP
    else:
        # for extended CP
        d_0 = [0] * 2 * M_symb
        for i in range(M_symb/2):
            if n_group_PHICH%2==0:
                d_0[4*i], d_0[4*i+1], d_0[4*i+2], d_0[4*i+3] = d[2*i], d[2*i+1], 0, 0
            else:
                # n_group_PHICH%2==1
                d_0[4*i], d_0[4*i+1], d_0[4*i+2], d_0[4*i+3] = 0, 0, d[2*i], d[2*i+1]
    
    # layer mapping.
    # TODO: refer to section 6.9.2 in 36.211. Check the code below
    x = numpy.matrix( '0 0 0 0 0 0; 0 0 0 0 0 0' )
    tmp = x.tolist()
    for i in range(6):
        for j in range(2):
#            print i*2 + j
            tmp[j][i] = d[i*j+j]
    x = tmp
    
    # precoding
    y = numpy.matrix( '0 0 0 0 0 0 0 0 0 0 0 0; 0 0 0 0 0 0 0 0 0 0 0 0' )
    y = y.tolist()
    for i in range(6):
        y[0][2*i] = sqrt(2)/2 * ( real(x[0][i]) + complex(0,1)*complex(0,1)*imag(x[0][i]) )
    for i in range(6):
        y[1][2*i] = sqrt(2)/2 * ( -1*real(x[1][i]) + complex(0,1)*complex(0,1)*imag(x[1][i]) )
    for i in range(6):
        y[0][2*i+1] = sqrt(2)/2 * ( real(x[1][i]) + complex(0,1)*complex(0,1)*imag(x[1][i]) )
    for i in range(6):
        y[1][2*i+1] = sqrt(2)/2 * ( real(x[0][i]) + complex(0,-1)*complex(0,1)*imag(x[0][i]) )
    return y
    
    
    
</t>
<t tx="michael.20120305092148.1276"></t>
<t tx="michael.20120305092148.1277"></t>
<t tx="michael.20120305092148.1278">def get_REG_in_RB_symbol(n_PRB, N_RB_sc, l, CSRS_AP_num, DL_CP_type):
    '''
    get_REG_in_RB_symbol(n_PRB, N_RB_sc, l, CSRS_AP_num, DL_CP_type): tuple of REGs
    Return REGs in the specific PRB of symbol l.
    n_PRB: PRB index
    N_RB_sc: number of subcarriers in one RB
    l: symbol index
    CSRS_AP_num: number of antenna uesed for Cell Specific Reference Signal
    DL_CP_type: 0 for normal CP, 1 for extended CP
    '''
    k_0 = n_PRB * N_RB_sc
    if l == 0:
        REGs = (    (   (k_0,l), (k_0+1,l), (k_0+2,l), (k_0+3,l), (k_0+4,l), (k_0+5,l) ),
                        ( (k_0+6,l), (k_0+7,l), (k_0+8,l), (k_0+9,l), (k_0+10,l), (k_0+11,l) )
                    )
    elif l ==1:
        if CSRS_AP_num == 4:
            REGs = (    (   (k_0,l), (k_0+1,l), (k_0+2,l), (k_0+3,l), (k_0+4,l), (k_0+5,l) ),
                        ( (k_0+6,l), (k_0+7,l), (k_0+8,l), (k_0+9,l), (k_0+10,l), (k_0+11,l) )
                    )
        else:   # it is the same for 1/2 CSRS APs, and also for calculating REG 2 CSRS APs shall be assumed for single AP configuration
            REGs = (    (   (k_0,l), (k_0+1,l), (k_0+2,l), (k_0+3,l)    ),
                            (   (k_0+4,l), (k_0+5,l), ( (k_0+6,l), (k_0+7,l)    ),
                            (   (k_0+8,l), (k_0+9,l), (k_0+10,l), (k_0+11,l)    )
                        )
    elif l ==2:
        REGs = (    (   (k_0,l), (k_0+1,l), (k_0+2,l), (k_0+3,l)    ),
                        (   (k_0+4,l), (k_0+5,l), ( (k_0+6,l), (k_0+7,l)    ),
                        (   (k_0+8,l), (k_0+9,l), (k_0+10,l), (k_0+11,l)    )
                    )
    elif l ==3:
        if DL_CP_type ==0:
            REGs = (    (   (k_0,l), (k_0+1,l), (k_0+2,l), (k_0+3,l)    ),
                            (   (k_0+4,l), (k_0+5,l), ( (k_0+6,l), (k_0+7,l)    ),
                            (   (k_0+8,l), (k_0+9,l), (k_0+10,l), (k_0+11,l)    )
                        )
        else:   # extended DL CP
            REGs = (    (   (k_0,l), (k_0+1,l), (k_0+2,l), (k_0+3,l), (k_0+4,l), (k_0+5,l) ),
                            ( (k_0+6,l), (k_0+7,l), (k_0+8,l), (k_0+9,l), (k_0+10,l), (k_0+11,l) )
                        )
    return REGs

def get_REG_in_RB_symbol_opti(n_PRB, N_RB_sc, l, CSRS_AP_num, DL_CP_type):
    '''
    Return REGs in the specific PRB of symbol l, optimized version.
    n_PRB: PRB index
    N_RB_sc: number of subcarriers in one RB
    l: symbol index
    CSRS_AP_num: number of antenna uesed for Cell Specific Reference Signal
    DL_CP_type: 0 for normal CP, 1 for extended CP
    '''
    k_0 = n_PRB * N_RB_sc
    if (l== 0) or (l==1 and CSRS_AP_num==4) or (l==3 and DL_CP_type==1):
        REGs = (    (   (k_0,l), (k_0+1,l), (k_0+2,l), (k_0+3,l), (k_0+4,l), (k_0+5,l) ),
                        (   (k_0+6,l), (k_0+7,l), (k_0+8,l), (k_0+9,l), (k_0+10,l), (k_0+11,l) )
                    )
    else:
        REGs = (    (   (k_0,l), (k_0+1,l), (k_0+2,l), (k_0+3,l)    ),
                        (   (k_0+4,l), (k_0+5,l), ( (k_0+6,l), (k_0+7,l)    ),
                        (   (k_0+8,l), (k_0+9,l), (k_0+10,l), (k_0+11,l)    )
                    )
    return REGs</t>
<t tx="michael.20120305092148.1279">def get_CSRS_REs_in_slot(n_s, antenna_port, N_cell_ID, N_maxDL_RB, N_DL_RB, N_DL_symb):
    '''
    get_CSRS_in_slot_RB_symbol(n_s, n_PRB, antenna_port, N_cell_ID, N_maxDL_RB, N_DL_RB, N_DL_symb): tuple of CSRS REs in the specified symbol of RB.
    n_s: slot index
    antenna_port: antenna port for CSRS
    N_cell_ID: cell ID
    N_maxDL_RB: 110 for 20MHz configured by higher layer
    N_DL_RB: PHY number of downlink RB
    N_DL_symb: maximum 110 for 20MHz
    
    profile:
def main():
    for i in range(1000):
        tmp = get_CSRS_in_slot(i%20, i%4, i, 110, 110, (7,3,2,4,5,1)[i%6])

cProfile.runctx('main()', globals(), locals())

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.012    0.012    0.903    0.903 &lt;ipython console&gt;:1(main)
     1000    0.536    0.001    0.891    0.001 &lt;ipython console&gt;:2(get_CSRS_in_slot)
    '''
    
    REs = list()
    # symbol indices for CSRS of this AP
    if antenna_port in (0,1):
        if N_DL_symb&gt;3:
            l_list = (0, N_DL_symb-3)
        else:   # DwPTS that has only 3 DL symbols
            l_list = (0,)
    else:   # antenna_port in (2,3)
        l_list = (1,)
    # v_shift
    v_shift = N_cell_ID % 6
    for l in l_list:
        # v
        if antenna_port==0 and l==0:
            v = 0
        elif antenna_port==0 and l!=0:
            v = 3
        elif antenna_port==1 and l==0:
            v = 3
        elif antenna_port==1 and l!=0:
            v = 0
        elif antenna_port==2:
            v = 3 * (n_s%2)
        elif antenna_port==3:
            v = 3 + 3 * (n_s%2)
        for m in range(2*N_DL_RB-1):
            m_ = m + N_maxDL_RB - N_DL_RB   # m'
            k = 6*m + (v+v_shift)%6
            REs.append( (k,l) )
    return tuple(REs)

def get_CSRS_in_symbol(n_s, l, antenna_port, N_cell_ID, N_maxDL_RB, N_DL_RB, N_RB_sc, N_DL_symb, DL_CP_type):
    '''
    '''
    symbol_array = ndarray(shape=(N_maxDL_RB*N_RB_sc,),dtype=complexfloating)
    for i in arange(len(symbol_array)):
        symbol_array[i] = 0
    csrs_seq = r_l_ns(n_s, l, N_cell_ID, N_maxDL_RB, DL_CP_type)
    # symbol indices for CSRS of this AP
    if antenna_port in (0,1):
        if N_DL_symb&gt;3:
            l_list = (0, N_DL_symb-3)
        else:   # DwPTS that has only 3 DL symbols
            l_list = (0,)
    else:   # antenna_port in (2,3)
        l_list = (1,)
    # v_shift
    v_shift = N_cell_ID % 6
    if l in l_list:
        # v
        if antenna_port==0 and l==0:
            v = 0
        elif antenna_port==0 and l!=0:
            v = 3
        elif antenna_port==1 and l==0:
            v = 3
        elif antenna_port==1 and l!=0:
            v = 0
        elif antenna_port==2:
            v = 3 * (n_s%2)
        elif antenna_port==3:
            v = 3 + 3 * (n_s%2)
        for m in range(2*N_DL_RB):
            m_ = m + N_maxDL_RB - N_DL_RB   # m'
            k = 6*m + (v+v_shift)%6
            symbol_array[k] = csrs_seq[m_]
    return symbol_array</t>
<t tx="michael.20120305092148.1280"></t>
<t tx="michael.20120305092148.1281"></t>
<t tx="michael.20120305092148.1283">def x_1(i):
    x1_init = 1
    while i&gt;30:
        tmp = (x1_init&amp;1 ^ x1_init&amp;8)%2
        x1_init = x1_init&gt;&gt;1 ^ tmp*(2**30)
        i -= 1
    return (x1_init &gt;&gt; i) &amp; 1

def x_2(c_init, i):
    while i&gt;30:
        tmp = (c_init&amp;1 ^ c_init&amp;2 ^ c_init&amp;4 ^ c_init&amp;8)%2
        c_init = c_init&gt;&gt;1 ^ tmp*(2**30)
        i -= 1
    return (c_init &gt;&gt; i) &amp; 1

def c(c_init, i):
    '''
    profile:
def main():
    for i in range(10000):
        c(i,i)

cProfile.runctx('main()', globals(), locals())

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
    10000    0.059    0.000   91.819    0.009 &lt;ipython console&gt;:1(c)
        1    0.023    0.023   91.843   91.843 &lt;ipython console&gt;:1(main)
    10000   39.318    0.004   39.318    0.004 &lt;ipython console&gt;:1(x_1)
    10000   52.441    0.005   52.441    0.005 &lt;ipython console&gt;:1(x_2)
    '''
    N_C = 1600
    return (x_1(i+N_C) + x_2(c_init,i+N_C)) %2
</t>
<t tx="michael.20120305092148.1285">def r_l_ns(n_s, l, N_cell_ID, N_maxDL_RB, DL_CP_type):
    '''
    r_l_ns(l, n_s, N_cell_ID, N_maxDL_RB, DL_CP_type): list of complex symbols for CSRS signal in symbol index l of given slot.
    l: symbol index in given slot
    n_s: slot index
    N_cell_ID:  cell ID
    N_maxDL_RB: 110 for 20MHz
    DL_CP_type: CP type for downlink, 0 for normal CP and 1 for extended CP
    
    profile:
import cProfile
from math import sqrt
def main():
    for i in range(100):
        tmp = r_l_ns(i%20, i%7, i, 110, i%2)

cProfile.runctx('main()', globals(), locals())

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
    44000    0.227    0.000  109.216    0.002 &lt;ipython console&gt;:1(c)
        1    0.001    0.001  109.585  109.585 &lt;ipython console&gt;:1(main)
      100    0.255    0.003  109.583    1.096 &lt;ipython console&gt;:1(r_l_ns)
    44000   46.434    0.001   46.434    0.001 &lt;ipython console&gt;:1(x_1)
    44000   62.555    0.001   62.555    0.001 &lt;ipython console&gt;:1(x_2)
    '''
    if DL_CP_type == 0: # normal DL CP
        N_CP = 1
    else:
        N_CP = 0
    c_init = 2**10 * (7*(n_s+1)+l+1) * (2*N_cell_ID+1) + 2*N_cell_ID + N_CP
    csrs_symbol_list = list()
    for m in range(2*N_maxDL_RB):
        real_part = 1/sqrt(2) * (1-2*c(c_init,2*m))
        image_part = 1/sqrt(2) * (1-2*c(c_init,2*m+1))
        csrs_symbol_list.append( complex(real_part,image_part) )
    return tuple(csrs_symbol_list)</t>
<t tx="michael.20120305092148.1290">def m_i( UL_DL_config, subframe ):
    m_i_table = (   (2,1,None,None,None,2,1,None,None,None),
                            (0,1,None,None,1,0,1,None,None,1),
                            (0,0,None,1,0,0,0,None,1,0),
                            (1,0,None,None,None,0,0,0,1,1,),
                            (0,0,None,None,0,0,0,0,1,1),
                            (0,0,None,0,0,0,0,0,1,0),
                            (1,1,None,None,None,1,1,None,None,1)
                    )
    return m_i_table[UL_DL_config][subframe]</t>
<t tx="michael.20120305092148.1291"></t>
<t tx="michael.20120305092148.1292">from numpy import *
import matplotlib.pyplot as plt

def plot_symbol(symbol_array, l, N_DL_CP, delta_f=15000):
    T_s = 1./30720  # all time scale is in 1 ms
    if N_DL_CP==0 and delta_f==15000:
        if l==0:
            N_CP_l = 160
        else:
            N_CP_l = 144
    elif N_DL_CP==1:    # extended CP
        if delta_f==15000:
            N_CP_l = 512
        else:   # delta_f == 7500
            N_CP_l = 1024
    if delta_f==15000:
        N = 2048
    else:   # delta_f == 7500
        N = 4096
    t = arange(0, (N_CP_l+N)*T_s, T_s)
    # use gnuplot
    plt.plot(t, symbol_array)
    plt.show()

def myplot(sig, t):
    plt.cla()
    plt.plot(t, sig)
    plt.xlabel('time (ms)')
    plt.show()
</t>
<t tx="michael.20120305092148.1293">def s_p_l(symbol_array, l, N_DL_RB, N_RB_sc, N_DL_CP, delta_f=15000):
    '''
    Note: len(symbol_array)==N_DL_RB*N_RB_sc must be True.
    '''
    T_s = 1./30720/1000  # all time scale is in 1 s
    if N_DL_CP==0 and delta_f==15000:
        if l==0:
            N_CP_l = 160
        else:
            N_CP_l = 144
    elif N_DL_CP==1:    # extended CP
        if delta_f==15000:
            N_CP_l = 512
        else:   # delta_f == 7500
            N_CP_l = 1024
    if delta_f==15000:
        N = 2048
    else:   # delta_f == 7500
        N = 4096
    t = arange(0, (N_CP_l+N)*T_s, T_s)
    signal_pl = 0
    down_limit = int(floor(N_DL_RB*N_RB_sc/2))
    up_limit = int(ceil(N_DL_RB*N_RB_sc/2))
    for k in arange( -1*down_limit, 0, 1 ):
        signal_pl += symbol_array[k+down_limit]*exp(1j*2*pi*k*delta_f*(t-N_CP_l*T_s))
    for k in arange(1, up_limit+1, 1):
        signal_pl += symbol_array[k+down_limit-1]*exp(1j*2*pi*k*delta_f*(t-N_CP_l*T_s))
    return signal_pl
</t>
<t tx="michael.20120305092148.1294"></t>
<t tx="michael.20120305092148.1295"></t>
<t tx="michael.20120305092148.1296">def downlink_modulate(s_p_l, t, f_0):
    return cos(2*pi*f_0*t) * s_p_l.real - sin(2*pi*f_0*t) * imag(s_p_l)

def downlink_downconvert(signal, t, f_0):
    
    cutoff_freq = f_0
    nyq = 2 * f_0
    numtaps = 80
    lp_fir = firwin(numtaps, cutoff_freq, window=('kaiser',8), nyq=nyq)
    
    I = -2* convolve( signal * cos(2*pi*f_0*t), lp_fir )[numtaps/2:len(signal)+numtaps/2]
    Q = -2 * convolve( signal * sin(2*pi*f_0*t), lp_fir )[numtaps/2:len(signal)+numtaps/2]
    
    return I + 1j*Q
</t>
<t tx="michael.20120305092148.1297"></t>
<t tx="michael.20120305092148.1298"># time scale is in 1 ms
T_s = 1.0/30720 # in ms
f_0 = (2620+0.1*(2620-2750))*1000*1000  # in kHz

@others

l = 0
N_DL_RB = 110
N_RB_sc = 12
N_DL_CP = 0

symbol_array = array([0]*N_DL_RB*N_RB_sc)
symbol_array[0] = 1
symbol_array[-1] = 1

baseband_sig = s_p_l(symbol_array, l, N_DL_RB, N_RB_sc, N_DL_CP, delta_f=15000)
t = arange(0, (160+2048)*T_s, T_s)
uu_sig = downlink_modulate(baseband_sig, t, f_0)
myplot(uu_sig, t)
</t>
<t tx="michael.20120305092148.1299"></t>
<t tx="michael.20120305092148.1301"></t>
<t tx="michael.20120305092148.1302"></t>
<t tx="michael.20120305092148.1303">def pss_d(n, N_ID_2):
    u = (25, 29, 34)[N_ID_2]
    d_n = 0
    if n&gt;=0 and n&lt;=30:
        d_n = exp(-1j*pi*u*n*(n+1)/63)
    elif n&gt;=31 and n&lt;=61:
        d_n = exp(-1j*pi*u*(n+1)*(n+2)/63)
    return d_n
</t>
<t tx="michael.20120305092148.1304"># u_th root Zadoff-Chu sequence
def x_u(u, n, N_ZC):
    if n&gt;=0 and n&lt;=N_ZC:
        return exp(-1j*pi*u*n*(n+1)/N_ZC)
    else:
        return 0

# u_th root Z-C sequence with v N_cs cyclic shift
def x_uv(u, v, n, N_ZC):
    pass</t>
<t tx="michael.20120305092148.1305">def pss_symbol_array(N_ID_2, N_DL_RB, N_RB_sc):
    symbol_array = ndarray( shape=(N_DL_RB*N_RB_sc,), dtype=complexfloating )
    for i in arange(len(symbol_array)):
        symbol_array[i] = 0
    for n in arange(0, 62):
        k = n-31+N_DL_RB*N_RB_sc/2
        symbol_array[k] = pss_d(n, N_ID_2)
    return symbol_array
</t>
<t tx="michael.20120305092148.1306"></t>
<t tx="michael.20120305092148.1307"></t>
<t tx="michael.20120305092148.1308"></t>
<t tx="michael.20120305092148.1310"># time scale is in 1 ms
T_s = 1.0/30720 # in ms
f_0 = (2620+0.1*(2620-2750))*1000*1000  # in kHz

@others

l = 0
N_DL_RB = 110
N_RB_sc = 12
N_DL_CP = 0 # normal DL CP

symbol_array = array([0]*N_DL_RB*N_RB_sc)
for i in arange(100):
    symbol_array[i] = 1

baseband_sig = s_p_l(symbol_array, l, N_DL_RB, N_RB_sc, N_DL_CP, delta_f=15000)
t = arange(0, (160+2048)*T_s, T_s)
uu_sig = downlink_modulate(baseband_sig, t, f_0)
myplot(uu_sig, t)</t>
<t tx="michael.20120305092148.1312"></t>
<t tx="michael.20120305092148.1313">from numpy import *
import matplotlib.pyplot as plt

# time scale is in 1 ms
T_s = 1.0/30720 # in ms
f_0 = (2620+0.1*(2620-2750))*1000*1000  # in kHz

@others

l = 0
N_DL_RB = 110
N_RB_sc = 12
N_DL_CP = 0 # normal DL CP
N_ZC = 63

zc_seq_d = dict()
for root_index in (29,34,25):
    zc_seq_d[root_index] = array([0]*N_ZC, dtype=complex128)
    for i in arange(N_ZC):
        zc_seq_d[root_index][i] = ZC(i, N_ZC, root_index)

cs_corr = array([0]*N_ZC)
for p in (29,34,25):
    for q in (29,34,25):
        for cs in arange(N_ZC):
            cs_corr[cs] = abs(correlate(zc_seq_d[p],roll(zc_seq_d[q],cs))[0])/N_ZC
            plt.cla()
            plt.axis( [-1, N_ZC+1, -0.1, 1.1] )
            plt.plot(cs_corr, marker='+', linestyle='-')
            fn = "cyclic_shift_corr_ZC_%s_%s.png"%(p,q)
            plt.savefig(fn)

</t>
<t tx="michael.20120305092148.1315"></t>
<t tx="michael.20120305092148.1316">def ZC( n, N_ZC, q ):
    '''
    give the n-th element of 0 cyclic shift Z-C sequence with root index q and length N_ZC.
    '''
    return exp(-1j*2*pi*q*n*(n+1)/2/N_ZC)
</t>
<t tx="michael.20120305092148.1317"></t>
<t tx="michael.20120305092148.1318">from numpy import *
from scipy.signal import *
import matplotlib.pyplot as plt

# time scale is in 1 s
T_s = 1.0/30720/1000 # in s

# configuration for PSS
l = 2
N_DL_RB = 110
N_RB_sc = 12
N_DL_CP = 0 # normal DL CP
N_ZC = 63
N_ID_2_tuple = (0,1,2)
delta_f = 15000
f_0 = (2620+0.1*(2620-2750))*1000*1000  # in Hz

if N_DL_CP==0 and delta_f==15000:
    if l==0:
        N_CP_l = 160
    else:
        N_CP_l = 144
elif N_DL_CP==1:    # extended CP
    if delta_f==15000:
        N_CP_l = 512
    else:   # delta_f == 7500
        N_CP_l = 1024
if delta_f==15000:
    N = 2048
else:   # delta_f == 7500
    N = 4096

t = arange(0, (N_CP_l+N)*T_s, T_s)

def find_max( a_list ):
    m = max(a_list)
    for i in arange(len(a_list)):
        if a_list[i] == m:
            return (i, m)

def find_min( a_array ):
    x, y = 0, 0
    for i in arange(len(a_array)):
        if a_array[i] &lt; y:
            x, y = i, a_array[i]
    return (x,y)

def find_abs_max( a_array ):
    m = max(abs(a_array))
    for i in arange(len(a_array)):
        if abs(a_array[i]) == m:
            return (i, m)

            
@others

test_enabling_bits = 0b10000000000

# 01. PSS spectrum before OFDM generation
if test_enabling_bits &amp; (1&lt;&lt;0):
    PSS_spectrum_before_OFDM_generation()

# 02. PSS correlation in freq domain before OFDM gen
if test_enabling_bits &amp; (1&lt;&lt;1):
    PSS_corr_in_freq_domain_before_OFDM_gen()

# 03. PSS baseband IQ signal in time domain
if test_enabling_bits &amp; (1&lt;&lt;2):
    PSS_baseband_IQ_signal_in_time_domain()

# 04. PSS baseband IQ spectrum
if test_enabling_bits &amp; (1&lt;&lt;3):
    PSS_baseband_IQ_spectrum()

# 05. PSS baseband IQ spectrum correlation
if test_enabling_bits &amp; (1&lt;&lt;4):
    PSS_baseband_IQ_spectrum_correlation()

# 06. PSS Uu signal 
if test_enabling_bits &amp; (1&lt;&lt;5):
    PSS_signal_Uu()

# 07. PSS signal Uu downconversion
if test_enabling_bits &amp; (1&lt;&lt;6):
    PSS_signal_Uu_downconversion()

# 08. PSS Uu signal downconverted correlation
if test_enabling_bits &amp; (1&lt;&lt;7):
    PSS_Uu_signal_downconverted_correlation()

# 09. PSS received IQ spectrum
if test_enabling_bits &amp; (1&lt;&lt;8):
    PSS_received_IQ_spectrum()

# 10. PSS Uu signal downconverted decimated to 1/16 correlation
if test_enabling_bits &amp; (1&lt;&lt;9):
    PSS_Uu_signal_downconverted_decimated_1_16_correlation()

# 11. PSS detect
if test_enabling_bits &amp; (1&lt;&lt;10):
    test_PSS_detect_in_baseband_IQ()


</t>
<t tx="michael.20120305092148.1320">def PSS_corr_in_freq_domain_before_OFDM_gen(to_draw=True):
    
    zc_seq_d = dict()
    for N_ID_2 in N_ID_2_tuple:
        zc_seq_d[N_ID_2] = array([0]*N_ZC, dtype=complex128)
        for i in arange(N_ZC-1):
            if i&lt;=30:
                zc_seq_d[N_ID_2][i] = pss_d(i, N_ID_2)
            else:
                zc_seq_d[N_ID_2][i] = pss_d(i, N_ID_2)
    
    legend_list = list()
    corr_dict = dict()
    max_dict = dict()
    cs_list = arange(-1*(N_ZC/2), N_ZC/2+1, 1)
    y_offsets = dict()
    y_offsets[(0,0)] = -20
    y_offsets[(0,1)] = 10
    y_offsets[(0,2)] = 20
    y_offsets[(1,1)] = -40
    y_offsets[(1,2)] = 20
    y_offsets[(2,2)] = -60
    
    overall_max_y = 0
    #print cs_corr.shape, cs_list.shape
    for p in N_ID_2_tuple:
        for q in N_ID_2_tuple:
            if p&lt;=q:
                corr_dict[(p,q)] = array([0]*N_ZC)
                for i in arange(len(cs_list)):
                    corr_dict[(p,q)][i] = abs(correlate(zc_seq_d[p],roll(zc_seq_d[q],cs_list[i]))[0])
                max_dict[(p,q)] = find_max(corr_dict[(p,q)])
    # normalize the correlation results
    overall_max_y = 0
    for k in max_dict.keys():
        x, y = max_dict[k]
        if y&gt;overall_max_y:
            overall_max_y = y
    overall_max_y = float(overall_max_y)
    for k in max_dict.keys():
        x, y = max_dict[k]
        max_dict[k] = (x, y/overall_max_y)
    for k in corr_dict.keys():
        corr_dict[k] = corr_dict[k]/overall_max_y
    if to_draw:
        for p,q in corr_dict.keys():
            plt.plot(cs_list, corr_dict[(p,q)], marker='+', linestyle='-')
            legend_list.append( 'N_ID_2 %s vs. %s'%(p,q) )
            x, y = max_dict[(p,q)]
            plt.annotate('Max of N_ID_2 %svs%s =%4.4s @ cs=%s'%(p,q,y,cs_list[x]), xy=(cs_list[x], y), arrowprops=dict(facecolor='black', shrink=0.15), textcoords='offset points', xytext=(60, y_offsets[(p,q)]))
        plt.title('PSS correlation in freq domain before OFDM generation')
        plt.legend(legend_list)
        plt.xlabel("Cyclic Shift")
        plt.ylabel("Correlation (normalized to peak)")
        plt.show()
    
    return corr_dict

    #plt.savefig('PSS_corr_in_freq_domain_before_OFDM_gen.png', dpi=300)
</t>
<t tx="michael.20120305092148.1321">def PSS_baseband_IQ_signal_in_time_domain():
    
    subplot_pos_tupe = (    (331,332,333),
                                    (334,335,336),
                                    (337,338,339)
                                )
    title_tuple = ('PSS baseband IQ OFDM signal magnitude','PSS baseband IQ OFDM signal real part','PSS baseband IQ OFDM signal imag part')
    y_label_tuple = ('IQ Magnitude', 'I part', 'Q part')
    func_tuple = (abs, real, imag)
    pss_baseband_symbol_list = [0]*3
    for N_ID_2 in N_ID_2_tuple:
        pss_freq_symbol_array = pss_symbol_array(N_ID_2, N_DL_RB, N_RB_sc)
        pss_baseband_symbol_list[N_ID_2] = s_p_l(pss_freq_symbol_array, l, N_DL_RB, N_RB_sc, N_DL_CP, delta_f)
        
    for i in (0,1,2):
        for N_ID_2 in N_ID_2_tuple:
            plt.subplot(131+N_ID_2)
            if N_ID_2 == 1:
                plt.title(title_tuple[i])
            plt.plot(t*1000, func_tuple[i](pss_baseband_symbol_list[N_ID_2]))
            plt.xlabel('Time (ms)')
            plt.ylabel(y_label_tuple[i])
            plt.axis([-0.01, 0.075, 0, 15])
            plt.legend( ('N_ID_2=%s'%N_ID_2,) )
            
        plt.show()
</t>
<t tx="michael.20120305092148.1322">def PSS_spectrum_before_OFDM_generation(to_draw=True):
    
    subplot_pos_tuple = (221,222,223)
    
    for N_ID_2 in N_ID_2_tuple:
        
        plt.subplot(subplot_pos_tuple[N_ID_2])
        legend_list = list()
        pss_freq_symbol_array = pss_symbol_array(N_ID_2, N_DL_RB, N_RB_sc)
        plt.title('PSS spectrum for N_ID_2=%s'%N_ID_2)
        legend_list.append( 'Spectrum magnitude' )
        plt.plot(abs(pss_freq_symbol_array), linestyle='-')
        #legend_list.append( 'Spectrum phase' )
        #plt.plot(abs(pss_freq_symbol_array), linestyle='-')
        plt.xlabel('k (subcarrier index)')
        plt.ylabel('Spectrum magnitude')
        plt.legend(legend_list)
    plt.show()
        #plt.savefig('PSS_spectrum_before_OFDM_gen_for_N_ID_2=%s.png'%N_ID_2)
</t>
<t tx="michael.20120305092148.1323">def PSS_signal_Uu():
    
    for N_ID_2 in N_ID_2_tuple:
        
        pss_freq_symbol_array = pss_symbol_array(N_ID_2, N_DL_RB, N_RB_sc)
        pss_baseband_symbol = s_p_l(pss_freq_symbol_array, l, N_DL_RB, N_RB_sc, N_DL_CP, delta_f)
        pss_uu_sig = downlink_modulate(pss_baseband_symbol, t, f_0)
        
        #plt.plot(t, symbol_array)
        plt.cla()
        legend_list = list()
        plt.plot(t*1000, pss_uu_sig)
        legend_list.append( 'PSS signal @Uu for N_ID_2=%s'%(N_ID_2) )
        plt.title('PSS signal @Uu for N_ID_2=%s'%N_ID_2)
        plt.xlabel('Time (ms)')
        plt.ylabel('Signal level')
        plt.legend(legend_list)
        #plt.axis( [-0.01, 0.075, -0.1, 14] )
        plt.show()
        #plt.savefig('PSS_signal_Uu_for_N_ID_2=%s.png'%N_ID_2, dpi=300)
</t>
<t tx="michael.20120305092148.1324">def PSS_received_IQ_convolve(to_draw=True):
    
    pss_iq_sig_list = [0]*3
    pss_baseband_IQ_list = [0] * 3
    
    for N_ID_2 in N_ID_2_tuple:
        
        pss_freq_symbol_array = pss_symbol_array(N_ID_2, N_DL_RB, N_RB_sc)
        pss_baseband_IQ_list[N_ID_2] = s_p_l(pss_freq_symbol_array, l, N_DL_RB, N_RB_sc, N_DL_CP, delta_f)
        pss_uu_sig = downlink_modulate(pss_baseband_IQ_list[N_ID_2], t, f_0)
        pss_iq_sig_list[N_ID_2] = downlink_downconvert(pss_uu_sig, t, f_0)[-1*N:]
    
    sig_sample_num = N
    cs_corr = array([0]*sig_sample_num)
    cs_list = arange(-1*(sig_sample_num/2), sig_sample_num/2, 1)
    #print cs_corr.shape, cs_list.shape
    plt.cla()
    legend_list = list()
    y_offsets = dict()
    y_offsets[(0,0)] = -10
    y_offsets[(0,1)] = 10
    y_offsets[(0,2)] = 20
    y_offsets[(1,1)] = -10
    y_offsets[(1,2)] = 10
    y_offsets[(2,2)] = -30
    for p in N_ID_2_tuple:
        for q in N_ID_2_tuple:
            if p&lt;=q:
                for i in arange(len(cs_list)):
                    cs_corr[i] = abs(sum(convolve(pss_baseband_IQ_list[p], roll(pss_iq_sig_list[q],cs_list[i]))[0]))
                plt.plot(cs_list, cs_corr, marker='+', linestyle='-')
                legend_list.append( 'N_ID_2 %s vs. %s'%(p,q) )
                # add anotation to the max
                x, y = find_max(cs_corr)
                plt.annotate('Max of N_ID_2 %svs%s =%s @ cs=%s'%(p,q,y,cs_list[x]), xy=(cs_list[x], y), arrowprops=dict(facecolor='black', shrink=0.15), textcoords='offset points', xytext=(40, y_offsets[(p,q)]))
                
    plt.title('PSS received IQ correlation')
    plt.xlabel('Cyclic Shift')
    plt.ylabel('Correlation value')
    plt.legend(legend_list)
    plt.show()
    #plt.savefig('PSS_Uu_signal_inner_products.png', figsize=(1280,800), dpi=200, pad_inches=2)
</t>
<t tx="michael.20120305092148.1325">def PSS_received_IQ_decimated_16():
    
    for N_ID_2 in N_ID_2_tuple:
        
        pss_freq_symbol_array = pss_symbol_array(N_ID_2, N_DL_RB, N_RB_sc)
        pss_baseband_symbol = s_p_l(pss_freq_symbol_array, l, N_DL_RB, N_RB_sc, N_DL_CP, delta_f)
        pss_uu_sig = downlink_modulate(pss_baseband_symbol, t, f_0)
        length = len(pss_uu_sig)/16
        pss_uu_sig_dec = array([0]*length)
        for i in arange(len(pss_uu_sig_dec)):
            pss_uu_sig_dec[i] = pss_uu_sig[i*16]
        t_ = arange(0, length*16*T_s, 16*T_s)
        #print len(t), len(pss_uu_sig_dec)
        
        #plt.plot(t, symbol_array)
        plt.cla()
        legend_list = list()
        plt.plot(t_, pss_uu_sig_dec)
        legend_list.append( 'N_ID_2=%s'%(N_ID_2) )
        plt.title('PSS downconverted Uu signal decimated to 1/16 for N_ID_2=%s'%N_ID_2)
        plt.xlabel('Time (ms)')
        plt.ylabel('Signal level')
        plt.legend(legend_list)
        plt.axis( [-0.01, 0.075, -11, 7] )
        plt.show()
        #plt.savefig('PSS_signal_Uu_decimated64_for_N_ID_2=%s.png'%N_ID_2, dpi=300)
</t>
<t tx="michael.20120305092148.1326">def PSS_Uu_signal_downconverted_decimated_1_16_correlation(to_draw=True):
    
    pss_Uu_signal_downconverted_list = [0]*3
    
    for N_ID_2 in N_ID_2_tuple:
        pss_freq_symbol_array = pss_symbol_array(N_ID_2, N_DL_RB, N_RB_sc)
        pss_baseband_IQ = s_p_l(pss_freq_symbol_array, l, N_DL_RB, N_RB_sc, N_DL_CP, delta_f)
        pss_uu_sig = downlink_modulate(pss_baseband_IQ, t, f_0)
        pss_Uu_signal_downconverted_list[N_ID_2] = downlink_downconvert(pss_uu_sig, t, f_0)[-1*N:]
    
    N_16 = N/16
    pss_Uu_signal_downconverted_dec_list = [0]*3
    for N_ID_2 in N_ID_2_tuple:
        pss_Uu_signal_downconverted_dec_list[N_ID_2] = array([0.0+0.0*1j]*N_16)
        for i in arange(N_16):
            pss_Uu_signal_downconverted_dec_list[N_ID_2][i] = pss_Uu_signal_downconverted_list[N_ID_2][16*i]
    legend_list = list()
    corr_dict = dict()
    max_dict = dict()
    cs_list = arange(-1*(N_16/2), N_16/2, 1)
    #print cs_corr.shape, cs_list.shape
    legend_list = list()
    y_offsets = dict()
    y_offsets[(0,0)] = -20
    y_offsets[(0,1)] = 10
    y_offsets[(0,2)] = 20
    y_offsets[(1,1)] = -10
    y_offsets[(1,2)] = 10
    y_offsets[(2,2)] = -60
    for p in N_ID_2_tuple:
        for q in N_ID_2_tuple:
            if p&lt;=q:
                corr_dict[(p,q)] = array([0]*N_16)
                for i in arange(len(cs_list)):
                    corr_dict[(p,q)][i] = abs(correlate(pss_Uu_signal_downconverted_dec_list[p], roll(pss_Uu_signal_downconverted_dec_list[q],cs_list[i]))[0])
                max_dict[(p,q)] = find_max(corr_dict[(p,q)])
                
    overall_max_y = 0
    for k in max_dict.keys():
        x, y = max_dict[k]
        if y&gt;overall_max_y:
            overall_max_y = y
    overall_max_y = float(overall_max_y)
    for k in max_dict.keys():
        x, y = max_dict[k]
        max_dict[k] = (x, y/overall_max_y)
    for k in corr_dict.keys():
        corr_dict[k] = corr_dict[k]/overall_max_y
    if to_draw:
        for p,q in corr_dict.keys():
            plt.plot(cs_list, corr_dict[(p,q)], marker='+', linestyle='-')
            legend_list.append( 'N_ID_2 %s vs. %s'%(p,q) )
            x, y = max_dict[(p,q)]
            plt.annotate('Max of N_ID_2 %svs%s =%4.4s @ cs=%s'%(p,q,y,cs_list[x]), xy=(cs_list[x], y), arrowprops=dict(facecolor='black', shrink=0.15), textcoords='offset points', xytext=(60, y_offsets[(p,q)]))
        plt.title('PSS Uu signal downconverted correlation')
        plt.legend(legend_list)
        plt.xlabel("Cyclic Shift")
        plt.ylabel("Correlation (normalized to peak)")
        plt.show()
    
    return corr_dict
</t>
<t tx="michael.20120305092148.1327">def PSS_received_IQ_FFT():
    
    func_tuple = (abs, real, imag)
    legend_tuple = ('Absolute', 'Real part', 'Image part')
    
    
    for N_ID_2 in N_ID_2_tuple:
        
        pss_freq_symbol_array = pss_symbol_array(N_ID_2, N_DL_RB, N_RB_sc)
        pss_baseband_symbol = s_p_l(pss_freq_symbol_array, l, N_DL_RB, N_RB_sc, N_DL_CP, delta_f)
        pss_uu_sig = downlink_modulate(pss_baseband_symbol, t, f_0)
        pss_uu_sig_down = downlink_downconvert(pss_uu_sig, t, f_0)
        pss_uu_sig_down_no_cp = pss_uu_sig_down[-1*N:]
        pss_uu_fft = fft.fft( pss_uu_sig_down_no_cp, N )
        
        for i in (0,1,2):
            plt.subplot(131+i)
            if i==1:
                plt.title('PSS received IQ FFT for N_ID_2=%s'%N_ID_2)
            legend_list = list()
            plt.plot(func_tuple[i](pss_uu_fft))
            legend_list.append( legend_tuple[i] )
            plt.xlabel('N')
            #plt.ylabel('Spectrum absolute value')
            plt.legend(legend_list)
            #plt.axis( [-0.01, 0.075, -0.1, 14] )
        plt.show()
            #plt.savefig('PSS_signal_Uu_for_N_ID_2=%s.png'%N_ID_2, dpi=300)
</t>
<t tx="michael.20120305092148.1328">def PSS_received_IQ_FFT_N_correlation():
    
    pss_baseband_IQ_fft_list = [0] * 3
    pss_received_IQ_fft_list = [0]*3
    pss_received_IQ_list = [0] * 3
    for N_ID_2 in N_ID_2_tuple:
        pss_freq_symbol_array = pss_symbol_array(N_ID_2, N_DL_RB, N_RB_sc)
        pss_baseband_IQ = s_p_l(pss_freq_symbol_array, l, N_DL_RB, N_RB_sc, N_DL_CP, delta_f)
        pss_baseband_IQ_fft_list[N_ID_2] = fft.fft(pss_baseband_IQ, N)
        pss_uu_sig = downlink_modulate(pss_baseband_IQ, t, f_0)
        pss_received_IQ_list[N_ID_2] = downlink_downconvert(pss_uu_sig, t, f_0)[-1*N:]
        #pss_received_IQ_fft_list[N_ID_2] = fft.fft( pss_received_IQ, N )
    
    
    legend_list = list()
    cs_corr = array([0]*N)
    cs_list = arange(-1*(N/2), N/2, 1)
    y_offsets = dict()
    y_offsets[(0,0)] = 0
    y_offsets[(0,1)] = 10
    y_offsets[(0,2)] = 20
    y_offsets[(1,1)] = -40
    y_offsets[(1,2)] = 20
    y_offsets[(2,2)] = -50
    #print cs_corr.shape, cs_list.shape
    for p in N_ID_2_tuple:
        for q in N_ID_2_tuple:
            if p&lt;=q:
                for i in arange(len(cs_list)):
                    cs_corr[i] = abs(correlate(pss_baseband_IQ_fft_list[p],fft.fft(roll(pss_received_IQ_list[q],cs_list[i])))[0])
                plt.plot(cs_list, cs_corr, marker='+', linestyle='-')
                legend_list.append( 'N_ID_2 %s vs. %s'%(p,q) )
                # add anotation to the max
                x, y = find_max(cs_corr)
                plt.annotate('Max of N_ID_2 %svs%s =%s @ cs=%s'%(p,q,y,cs_list[x]), xy=(cs_list[x], y), arrowprops=dict(facecolor='black', shrink=0.15), textcoords='offset points', xytext=(60, y_offsets[(p,q)]))
    
    plt.title('PSS Uu signal FFT correlation')
    plt.legend(legend_list)
    plt.xlabel("Cyclic Shift")
    plt.ylabel("Correlation")
    plt.show()
</t>
<t tx="michael.20120305092148.1329">def PSS_Uu_signal_FFT_N_16_correlation():
    
    N_16 = N/16
    
    pss_uu_signal_fft_list = [0]*3
    t = arange(0, (N_CP_l+N)*T_s, T_s)
    for N_ID_2 in N_ID_2_tuple:
        pss_freq_symbol_array = pss_symbol_array(N_ID_2, N_DL_RB, N_RB_sc)
        pss_baseband_symbol = s_p_l(pss_freq_symbol_array, l, N_DL_RB, N_RB_sc, N_DL_CP, delta_f)
        pss_uu_sig = downlink_modulate(pss_baseband_symbol, t, f_0)
        pss_uu_sig_no_cp = pss_uu_sig[-1*N:]
        pss_uu_sig_no_cp_dec = array( [0]*N_16 )
        for i in range(N_16):
            pss_uu_sig_no_cp_dec[i] = pss_uu_sig_no_cp[i*16]
        pss_uu_signal_fft_list[N_ID_2] = fft.fft( pss_uu_sig_no_cp_dec, N_16 )
    
    
    legend_list = list()
    cs_corr = array([0]*N_16)
    cs_list = arange(-1*(N_16/2), N_16/2, 1)
    y_offsets = dict()
    y_offsets[(0,0)] = 0
    y_offsets[(0,1)] = 10
    y_offsets[(0,2)] = 20
    y_offsets[(1,1)] = 0
    y_offsets[(1,2)] = 20
    y_offsets[(2,2)] = -10
    #print cs_corr.shape, cs_list.shape
    for p in N_ID_2_tuple:
        for q in N_ID_2_tuple:
            if p&lt;=q:
                for i in arange(len(cs_list)):
                    cs_corr[i] = abs(correlate(pss_uu_signal_fft_list[p],roll(pss_uu_signal_fft_list[q],cs_list[i]))[0])
                plt.plot(cs_list, cs_corr, marker='+', linestyle='-')
                legend_list.append( 'N_ID_2 %s vs. %s'%(p,q) )
                # add anotation to the max
                x, y = find_max(cs_corr)
                plt.annotate('Max of N_ID_2 %svs%s =%s @ cs=%s'%(p,q,y,cs_list[x]), xy=(cs_list[x], y), arrowprops=dict(facecolor='black', shrink=0.15), textcoords='offset points', xytext=(60, y_offsets[(p,q)]))
    
    plt.title('PSS Uu signal decimated to 1/16 FFT correlation')
    plt.legend(legend_list)
    plt.xlabel("Cyclic Shift")
    plt.ylabel("Correlation")
    plt.show()
</t>
<t tx="michael.20120305092148.1330">def test(to_draw=True):
    
    subplot_pos_tuple = (221,222,223)
    
    for N_ID_2 in N_ID_2_tuple:
        
        plt.subplot(subplot_pos_tuple[N_ID_2])
        legend_list = list()
        all_subcarrier_array = array([0] * (N_DL_RB * N_RB_sc+1))
        pss_freq_symbol_array = pss_symbol_array(N_ID_2, N_DL_RB, N_RB_sc)
        all_subcarrier_array[:N_DL_RB*N_RB_sc/2]
        pss_baseband_IQ = s_p_l(pss_freq_symbol_array, l, N_DL_RB, N_RB_sc, N_DL_CP, delta_f)[-1*N:]
        pss_baseband_IQ_fft = fft.fft(pss_baseband_IQ, N)
        plt.title('PSS baseband IQ spectrum for N_ID_2=%s'%N_ID_2)
        legend_list.append( 'Spectrum magnitude' )
        plt.plot(abs(pss_baseband_IQ_fft), linestyle='-')
        #legend_list.append( 'Spectrum phase' )
        #plt.plot(abs(pss_freq_symbol_array), linestyle='-')
        plt.xlabel('n (FFT index)')
        plt.ylabel('Spectrum magnitude')
        plt.legend(legend_list)
    plt.show()
        #plt.savefig('PSS_spectrum_before_OFDM_gen_for_N_ID_2=%s.png'%N_ID_2)
</t>
<t tx="michael.20120305092148.1331">from numpy import *
import matplotlib.pyplot as plt



@others


def z_fft_of_ZC():
    
    l = 0
    N_DL_RB = 110
    N_RB_sc = 12
    N_DL_CP = 0 # normal DL CP
    N_ZC = 61
    
    zc_seq = array( [0]*(N_ZC), dtype=complex128 )
    #print len(zc_seq)
    for i in arange(N_ZC):
        zc_seq[i] = ZC(i, N_ZC, 7)
    
    plt.subplot(141)
    plt.plot(abs(zc_seq))
    
    #plt.subplot(142)
    #plt.plot(abs(fft.fft(zc_seq)))
    
    plt.subplot(142)
    n_seq = arange(N_ZC)
    x = 0
    for k in arange(N_ZC):
        x += zc_seq[k]*exp(1j*2*pi*k*n_seq/N_ZC)
    x = x/N_ZC
    plt.plot(abs(x))
    
    #plt.subplot(143)
    #plt.plot(abs(fft.ifft(fft.fft(zc_seq))))
    
    plt.subplot(144)
    plt.plot(abs(fft.ifft(zc_seq)))
    
    plt.show()

</t>
<t tx="michael.20120309091906.1376"></t>
<t tx="michael.20120309091906.1377">from numpy import *
import matplotlib.pyplot as plt
from scipy.signal import *


def low_pass_filter():
    
    T_s = 0.01/307200
    t = arange(0, 2048*T_s, T_s)
    delta_f = 15*1000
    
    f_0_start = 10*1000*1000 + delta_f * 12 * 50
    f_0_end = f_0_start + delta_f * 12
    
    f_1_start = 10*1000*1000 - delta_f * 0
    f_1_end = f_1_start - delta_f * 1
    
    sig_01 = 0
    for f in arange(f_0_start, f_0_end):
        sig_01 += cos(2*pi*f*t) - sin(2*pi*f*t)
    
    sig_02 = 0
    for f in arange(f_1_start, f_1_end, -1):
        sig_02 += cos(2*pi*f*t) - sin(2*pi*f*t)
    #sig_01 = exp(-1j*2*pi*f_0*t)
    #sig_02 = exp(-1j*2*pi*f_1*t)
    #plt.plot(t, sig_01)
    #plt.plot(t, sig_02)
    fft_01 = fft.fft(sig_01, 4096)
    fft_02 = fft.fft(sig_02, 4096)
    
    legend_list = list()
    plt.plot(abs(fft_01))
    legend_list.append('FFT of sig_01 %6.6sMHz to %6.6sMHz'%(f_0_start/1000./1000, f_0_end/1000./1000))
    plt.plot(abs(fft_02))
    legend_list.append('FFT of sig_02 %6.6sMHz to %6.6sMHz'%(f_1_start/1000./1000, f_1_end/1000./1000))
    plt.legend(legend_list)
    
    
    plt.axis( [-10, 2050, -10, 10 + max(abs(fft_01))] )
    #plt.axis( [-10, 2050, -10, 10 + max(max(abs(fft_01)), max(abs(fft_02)))] )
    plt.show()

def fir_low_pass(nyq, cutoff):
    
    b = firwin(80, cutoff, window=('kaiser', 8), nyq=nyq)
    h, w = freqz(b, worN=80)
    fig = plt.figure()
    plt.title('Digital filter frequency response')
    ax1 = fig.add_subplot(111)
    plt.semilogy(h, np.abs(w), 'b')
    plt.ylabel('Amplitude (dB)', color='b')
    plt.xlabel('Frequency (rad/sample)')
    plt.grid()
    plt.legend()
    ax2 = ax1.twinx()
    angles = unwrap(angle(w))
    plt.plot(h, angles, 'g')
    plt.ylabel('Angle (radians)', color='g')
    plt.show()
    

fir_low_pass(20*1000*1000, 10*1000*1000)
</t>
<t tx="michael.20120309091906.1379">def PSS_Uu_signal_FFT_after_10MHzlowpass_filter():
    
    func_tuple = (abs, real, imag)
    legend_tuple = ('Absolute', 'Real part', 'Image part')
    
    cutoff_freq = 10*1000*1000
    nyq = 20*1000*1000
    lp_fir = firwin(80, cutoff_freq, window=('kaiser',8), nyq=20*1000*1000)
    
    
    for N_ID_2 in N_ID_2_tuple:
        
        pss_freq_symbol_array = pss_symbol_array(N_ID_2, N_DL_RB, N_RB_sc)
        pss_baseband_symbol = s_p_l(pss_freq_symbol_array, l, N_DL_RB, N_RB_sc, N_DL_CP, delta_f)
        pss_uu_sig = downlink_modulate(pss_baseband_symbol, t, f_0)
        pss_uu_sig_no_cp = pss_uu_sig[-1*N:]
        # apply an low pass FIR filter
        pss_uu_sig_no_cp_after_lp = convolve(pss_uu_sig_no_cp, lp_fir)
        pss_uu_fft = fft.fft( pss_uu_sig_no_cp_after_lp, N )
        
        for i in (0,1,2):
            plt.subplot(131+i)
            if i==1:
                plt.title('PSS signal Uu FFT after 10MHZ low-pass filter for N_ID_2=%s'%N_ID_2)
            legend_list = list()
            plt.plot(func_tuple[i](pss_uu_fft))
            legend_list.append( legend_tuple[i] )
            plt.xlabel('N')
            #plt.ylabel('Spectrum absolute value')
            plt.legend(legend_list)
            #plt.axis( [-0.01, 0.075, -0.1, 14] )
        plt.show()
            #plt.savefig('PSS_signal_Uu_for_N_ID_2=%s.png'%N_ID_2, dpi=300)
</t>
<t tx="michael.20120309091906.1380">def PSS_Uu_signal_FFT_after_10MHzlowpass_N_correlation():
    
    cutoff_freq = 10*1000*1000
    nyq = 20*1000*1000
    lp_fir = firwin(80, cutoff_freq, window=('kaiser',8), nyq=20*1000*1000)
    
    pss_uu_signal_fft_list = [0]*3

    for N_ID_2 in N_ID_2_tuple:
        pss_freq_symbol_array = pss_symbol_array(N_ID_2, N_DL_RB, N_RB_sc)
        pss_baseband_symbol = s_p_l(pss_freq_symbol_array, l, N_DL_RB, N_RB_sc, N_DL_CP, delta_f)
        pss_uu_sig = downlink_modulate(pss_baseband_symbol, t, f_0)
        pss_uu_sig_no_cp = pss_uu_sig[-1*N:]
        # apply an low pass FIR filter
        pss_uu_sig_no_cp_after_lp = convolve(pss_uu_sig_no_cp, lp_fir)
        pss_uu_signal_fft_list[N_ID_2] = fft.fft( pss_uu_sig_no_cp_after_lp, N )
    
    
    legend_list = list()
    
    cs_list = arange(-1*(N/2), N/2, 1)
    y_offsets = dict()
    y_offsets[(0,0)] = 0
    y_offsets[(0,1)] = 10
    y_offsets[(0,2)] = 20
    y_offsets[(1,1)] = -40
    y_offsets[(1,2)] = 20
    y_offsets[(2,2)] = -60
    #corr_dict = dict()
    #print cs_corr.shape, cs_list.shape
    for p in N_ID_2_tuple:
        for q in N_ID_2_tuple:
            if p&lt;=q:
                cs_corr = array([0]*N)
                for i in arange(len(cs_list)):
                    cs_corr[i] = abs(correlate(pss_uu_signal_fft_list[p],roll(pss_uu_signal_fft_list[q],cs_list[i]))[0])
                #corr_dict[(p,q)] = cs_corr
                plt.plot(cs_list, cs_corr, marker='+', linestyle='-')
                legend_list.append( 'N_ID_2 %s vs. %s'%(p,q) )
                # add anotation to the max
                x, y = find_max(cs_corr)
                plt.annotate('Max of N_ID_2 %svs%s =%s @ cs=%s'%(p,q,y,cs_list[x]), xy=(cs_list[x], y), arrowprops=dict(facecolor='black', shrink=0.15), textcoords='offset points', xytext=(60, y_offsets[(p,q)]))
    
    plt.title('PSS Uu signal FFT after 10MHz low-pass filter correlation')
    plt.legend(legend_list)
    plt.xlabel("Cyclic Shift")
    plt.ylabel("Correlation")
    plt.show()
</t>
<t tx="michael.20120309091906.1381">def PSS_Uu_signal_FFT_after_10MHzlowpass_N_16_correlation():
    
    cutoff_freq = 10*1000*1000
    nyq = 20*1000*1000
    lp_fir = firwin(80, cutoff_freq, window=('kaiser',8), nyq=20*1000*1000)
    
    N_16 = N/16
    
    pss_uu_signal_fft_list = [0]*3

    for N_ID_2 in N_ID_2_tuple:
        pss_freq_symbol_array = pss_symbol_array(N_ID_2, N_DL_RB, N_RB_sc)
        pss_baseband_symbol = s_p_l(pss_freq_symbol_array, l, N_DL_RB, N_RB_sc, N_DL_CP, delta_f)
        pss_uu_sig = downlink_modulate(pss_baseband_symbol, t, f_0)
        pss_uu_sig_no_cp = pss_uu_sig[-1*N:]
        pss_uu_sig_no_cp_lp = convolve(pss_uu_sig_no_cp, lp_fir)
        pss_uu_sig_no_cp_dec = array( [0]*N_16 )
        for i in range(N_16):
            pss_uu_sig_no_cp_dec[i] = pss_uu_sig_no_cp_lp[i*16]
        pss_uu_signal_fft_list[N_ID_2] = fft.fft( pss_uu_sig_no_cp_dec, N_16 )
    
    
    legend_list = list()
    cs_corr = array([0]*N_16)
    cs_list = arange(-1*(N_16/2), N_16/2, 1)
    y_offsets = dict()
    y_offsets[(0,0)] = 0
    y_offsets[(0,1)] = 10
    y_offsets[(0,2)] = 20
    y_offsets[(1,1)] = 0
    y_offsets[(1,2)] = 20
    y_offsets[(2,2)] = -10
    #print cs_corr.shape, cs_list.shape
    for p in N_ID_2_tuple:
        for q in N_ID_2_tuple:
            if p&lt;=q:
                for i in arange(len(cs_list)):
                    cs_corr[i] = abs(correlate(pss_uu_signal_fft_list[p],roll(pss_uu_signal_fft_list[q],cs_list[i]))[0])
                plt.plot(cs_list, cs_corr, marker='+', linestyle='-')
                legend_list.append( 'N_ID_2 %s vs. %s'%(p,q) )
                # add anotation to the max
                x, y = find_max(cs_corr)
                plt.annotate('Max of N_ID_2 %svs%s =%s @ cs=%s'%(p,q,y,cs_list[x]), xy=(cs_list[x], y), arrowprops=dict(facecolor='black', shrink=0.15), textcoords='offset points', xytext=(60, y_offsets[(p,q)]))
    
    plt.title('PSS Uu signal after 10MHz low-pass filter then decimated to 1/16 FFT correlation')
    plt.legend(legend_list)
    plt.xlabel("Cyclic Shift")
    plt.ylabel("Correlation")
    plt.show()
</t>
<t tx="michael.20120309091906.1382">def PSS_Uu_signal_FFT_after_540KHzlowpass_filter():
    
    func_tuple = (abs, real, imag)
    legend_tuple = ('Absolute', 'Real part', 'Image part')
    
    cutoff_freq = 540*1000
    nyq = 20*1000*1000
    lp_fir = firwin(80, cutoff_freq, window=('kaiser',8), nyq=nyq)
    
    
    for N_ID_2 in N_ID_2_tuple:
        
        pss_freq_symbol_array = pss_symbol_array(N_ID_2, N_DL_RB, N_RB_sc)
        pss_baseband_symbol = s_p_l(pss_freq_symbol_array, l, N_DL_RB, N_RB_sc, N_DL_CP, delta_f)
        pss_uu_sig = downlink_modulate(pss_baseband_symbol, t, f_0)
        pss_uu_sig_no_cp = pss_uu_sig[-1*N:]
        
        # apply an low pass FIR filter
        pss_uu_sig_no_cp_after_lp = convolve(pss_uu_sig_no_cp, lp_fir)
        pss_uu_fft = fft.fft( pss_uu_sig_no_cp_after_lp, N )
        
        for i in (0,1,2):
            plt.subplot(131+i)
            if i==1:
                plt.title('PSS signal Uu FFT after 540KHZ low-pass filter for N_ID_2=%s'%N_ID_2)
            legend_list = list()
            plt.plot(func_tuple[i](pss_uu_fft))
            legend_list.append( legend_tuple[i] )
            plt.xlabel('N')
            #plt.ylabel('Spectrum absolute value')
            plt.legend(legend_list)
            #plt.axis( [-0.01, 0.075, -0.1, 14] )
        plt.show()
            #plt.savefig('PSS_signal_Uu_for_N_ID_2=%s.png'%N_ID_2, dpi=300)
</t>
<t tx="michael.20120309091906.1384">def PSS_Uu_signal_FFT_after_540KHzlowpass_N_correlation():
    
    cutoff_freq = 540*1000
    nyq = 20*1000*1000
    lp_fir = firwin(80, cutoff_freq, window=('kaiser',8), nyq=nyq)
    
    
    pss_uu_signal_fft_list = [0]*3

    for N_ID_2 in N_ID_2_tuple:
        pss_freq_symbol_array = pss_symbol_array(N_ID_2, N_DL_RB, N_RB_sc)
        pss_baseband_symbol = s_p_l(pss_freq_symbol_array, l, N_DL_RB, N_RB_sc, N_DL_CP, delta_f)
        pss_uu_sig = downlink_modulate(pss_baseband_symbol, t, f_0)
        pss_uu_sig_no_cp = pss_uu_sig[-1*N:]
        # apply an low pass FIR filter
        pss_uu_sig_no_cp_after_lp = convolve(pss_uu_sig_no_cp, lp_fir)
        pss_uu_signal_fft_list[N_ID_2] = fft.fft( pss_uu_sig_no_cp_after_lp, N )
    
    
    legend_list = list()
    
    cs_list = arange(-1*(N/2), N/2, 1)
    y_offsets = dict()
    y_offsets[(0,0)] = 0
    y_offsets[(0,1)] = -10
    y_offsets[(0,2)] = -20
    y_offsets[(1,1)] = -40
    y_offsets[(1,2)] = 20
    y_offsets[(2,2)] = -60
    #corr_dict = dict()
    #print cs_corr.shape, cs_list.shape
    for p in N_ID_2_tuple:
        for q in N_ID_2_tuple:
            if p&lt;=q:
                cs_corr = array([0]*N)
                for i in arange(len(cs_list)):
                    cs_corr[i] = abs(correlate(pss_uu_signal_fft_list[p],roll(pss_uu_signal_fft_list[q],cs_list[i]))[0])
                #corr_dict[(p,q)] = cs_corr
                plt.plot(cs_list, cs_corr, marker='+', linestyle='-')
                legend_list.append( 'N_ID_2 %s vs. %s'%(p,q) )
                # add anotation to the max
                x, y = find_max(cs_corr)
                plt.annotate('Max of N_ID_2 %svs%s =%s @ cs=%s'%(p,q,y,cs_list[x]), xy=(cs_list[x], y), arrowprops=dict(facecolor='black', shrink=0.15), textcoords='offset points', xytext=(60, y_offsets[(p,q)]))
    
    plt.title('PSS Uu signal FFT after 540KHz low-pass filter correlation')
    plt.legend(legend_list)
    plt.xlabel("Cyclic Shift")
    plt.ylabel("Correlation")
    plt.show()
</t>
<t tx="michael.20120309091906.1386">def PSS_Uu_signal_FFT_after_540KHzlowpass_N_16_correlation():
    
    cutoff_freq = 540*1000
    nyq = 20*1000*1000
    lp_fir = firwin(80, cutoff_freq, window=('kaiser',8), nyq=20*1000*1000)
    
    N_16 = N/16
    
    pss_uu_signal_fft_list = [0]*3

    for N_ID_2 in N_ID_2_tuple:
        pss_freq_symbol_array = pss_symbol_array(N_ID_2, N_DL_RB, N_RB_sc)
        pss_baseband_symbol = s_p_l(pss_freq_symbol_array, l, N_DL_RB, N_RB_sc, N_DL_CP, delta_f)
        pss_uu_sig = downlink_modulate(pss_baseband_symbol, t, f_0)
        pss_uu_sig_no_cp = pss_uu_sig[-1*N:]
        pss_uu_sig_no_cp_lp = convolve(pss_uu_sig_no_cp, lp_fir)
        pss_uu_sig_no_cp_dec = array( [0]*N_16 )
        for i in range(N_16):
            pss_uu_sig_no_cp_dec[i] = pss_uu_sig_no_cp_lp[i*16]
        pss_uu_signal_fft_list[N_ID_2] = fft.fft( pss_uu_sig_no_cp_dec, N_16 )
    
    
    legend_list = list()
    cs_corr = array([0]*N_16)
    cs_list = arange(-1*(N_16/2), N_16/2, 1)
    y_offsets = dict()
    y_offsets[(0,0)] = 0
    y_offsets[(0,1)] = 10
    y_offsets[(0,2)] = 20
    y_offsets[(1,1)] = 0
    y_offsets[(1,2)] = 20
    y_offsets[(2,2)] = -10
    #print cs_corr.shape, cs_list.shape
    for p in N_ID_2_tuple:
        for q in N_ID_2_tuple:
            if p&lt;=q:
                for i in arange(len(cs_list)):
                    cs_corr[i] = abs(correlate(pss_uu_signal_fft_list[p],roll(pss_uu_signal_fft_list[q],cs_list[i]))[0])
                plt.plot(cs_list, cs_corr, marker='+', linestyle='-')
                legend_list.append( 'N_ID_2 %s vs. %s'%(p,q) )
                # add anotation to the max
                x, y = find_max(cs_corr)
                plt.annotate('Max of N_ID_2 %svs%s =%s @ cs=%s'%(p,q,y,cs_list[x]), xy=(cs_list[x], y), arrowprops=dict(facecolor='black', shrink=0.15), textcoords='offset points', xytext=(60, y_offsets[(p,q)]))
    
    plt.title('PSS Uu signal after 540KHz low-pass filter then decimated to 1/16 FFT correlation')
    plt.legend(legend_list)
    plt.xlabel("Cyclic Shift")
    plt.ylabel("Correlation")
    plt.show()
</t>
<t tx="michael.20120309091906.1387">def PSS_signal_Uu_downconversion():
    
    
    for N_ID_2 in N_ID_2_tuple:
        
        pss_freq_symbol_array = pss_symbol_array(N_ID_2, N_DL_RB, N_RB_sc)
        pss_baseband_symbol = s_p_l(pss_freq_symbol_array, l, N_DL_RB, N_RB_sc, N_DL_CP, delta_f)
        pss_uu_sig = downlink_modulate(pss_baseband_symbol, t, f_0)
        pss_uu_sig_down = downlink_downconvert(pss_uu_sig, t, f_0)
        
        #plt.plot(t, symbol_array)
        legend_list = list()
        plt.plot(t*1000, real(pss_uu_sig_down))
        legend_list.append( 'PSS Uu signal downconverted for N_ID_2=%s'%(N_ID_2) )
        plt.plot(t*1000, real(pss_baseband_symbol))
        legend_list.append( 'PSS baseband IQ for N_ID_2=%s'%(N_ID_2) )
        plt.title('PSS signal Uu downconverted for N_ID_2=%s'%N_ID_2)
        plt.xlabel('Time (ms)')
        plt.ylabel('IQ signal real part')
        plt.legend(legend_list)
        #plt.axis( [-0.01, 0.075, -0.1, 14] )
        plt.show()
        #plt.savefig('PSS_signal_Uu_for_N_ID_2=%s.png'%N_ID_2, dpi=300)
</t>
<t tx="michael.20120309091906.1388">def plot_IQ_signal():
    '''
    
    '''
    
    subplot_pos_tupe = (    (331,332,333),
                                    (334,335,336),
                                    (337,338,339)
                                )
    title_tuple = ('PSS baseband IQ OFDM signal absolute value','PSS baseband IQ OFDM signal real part','PSS baseband IQ OFDM signal imag part')
    func_tuple = (abs, real, imag)
    pss_baseband_symbol_list = [0]*3
    for N_ID_2 in N_ID_2_tuple:
        pss_freq_symbol_array = pss_symbol_array(N_ID_2, N_DL_RB, N_RB_sc)
        pss_baseband_symbol_list[N_ID_2] = s_p_l(pss_freq_symbol_array, l, N_DL_RB, N_RB_sc, N_DL_CP, delta_f)
        
    for i in (0,1,2):
        if N_DL_CP==0 and delta_f==15000:
            if l==0:
                N_CP_l = 160
            else:
                N_CP_l = 144
        elif N_DL_CP==1:    # extended CP
            if delta_f==15000:
                N_CP_l = 512
            else:   # delta_f == 7500
                N_CP_l = 1024
        if delta_f==15000:
            N = 2048
        else:   # delta_f == 7500
            N = 4096
        t = arange(0, (N_CP_l+N)*T_s, T_s)
        for N_ID_2 in N_ID_2_tuple:
            plt.subplot(131+N_ID_2)
            if N_ID_2 == 1:
                plt.title(title_tuple[i])
            plt.plot(t, func_tuple[i](pss_baseband_symbol_list[N_ID_2]))
            plt.xlabel('Time (ms)')
            plt.axis([-0.01, 0.075, 0, 15])
            plt.legend( ('N_ID_2=%s'%N_ID_2,) )
            
        plt.show()
</t>
<t tx="michael.20120310203114.1394">def PSS_received_IQ_spectrum(to_draw=True):
    
    subplot_pos_tuple = (221,222,223)
    
    for N_ID_2 in N_ID_2_tuple:
        
        plt.subplot(subplot_pos_tuple[N_ID_2])
        legend_list = list()
        pss_freq_symbol_array = pss_symbol_array(N_ID_2, N_DL_RB, N_RB_sc)
        pss_baseband_symbol = s_p_l(pss_freq_symbol_array, l, N_DL_RB, N_RB_sc, N_DL_CP, delta_f)
        pss_uu_sig = downlink_modulate(pss_baseband_symbol, t, f_0)
        pss_uu_sig_down = downlink_downconvert(pss_uu_sig, t, f_0)[-1*N:]
        pss_uu_sig_down_fft = fft.fft(pss_uu_sig_down, N)
        plt.title('Received PSS IQ spectrum for N_ID_2=%s'%N_ID_2)
        legend_list.append( 'Spectrum magnitude' )
        plt.plot(abs(pss_uu_sig_down_fft), linestyle='-')
        #legend_list.append( 'Spectrum phase' )
        #plt.plot(abs(pss_freq_symbol_array), linestyle='-')
        plt.xlabel('n (FFT index)')
        plt.ylabel('Spectrum magnitude')
        plt.legend(legend_list)
    plt.show()
        #plt.savefig('PSS_spectrum_before_OFDM_gen_for_N_ID_2=%s.png'%N_ID_2)
</t>
<t tx="michael.20120310203114.1395">def PSS_baseband_IQ_spectrum(to_draw=True):
    
    subplot_pos_tuple = (221,222,223)
    
    for N_ID_2 in N_ID_2_tuple:
        
        plt.subplot(subplot_pos_tuple[N_ID_2])
        legend_list = list()
        pss_freq_symbol_array = pss_symbol_array(N_ID_2, N_DL_RB, N_RB_sc)
        #pss_freq_symbol_array_ext = array([0+0*1j]*N)
        #pss_freq_symbol_array_ext[N/2-31:N/2] = pss_freq_symbol_array[len(pss_freq_symbol_array)/2-31:len(pss_freq_symbol_array)/2]
        #pss_freq_symbol_array_ext[N/2:N/2+31] = pss_freq_symbol_array[len(pss_freq_symbol_array)/2:len(pss_freq_symbol_array)/2+31]
        #print pss_freq_symbol_array_ext[N/2]
        #pss_ifft = fft.ifft(pss_freq_symbol_array, N)
        #pss_fft = fft.fft(pss_ifft, N)
        pss_baseband_IQ = s_p_l(pss_freq_symbol_array, l, N_DL_RB, N_RB_sc, N_DL_CP, delta_f)[-1*N:]
        pss_baseband_IQ_fft = fft.fft(pss_baseband_IQ, N)
        plt.title('PSS baseband IQ spectrum for N_ID_2=%s'%N_ID_2)
        legend_list.append( 'Spectrum magnitude' )
        plt.plot(abs(pss_baseband_IQ_fft), linestyle='-')
        #legend_list.append( 'Spectrum phase' )
        #plt.plot(abs(pss_freq_symbol_array), linestyle='-')
        plt.xlabel('n (FFT index)')
        plt.ylabel('Spectrum magnitude')
        plt.legend(legend_list)
    plt.show()
        #plt.savefig('PSS_spectrum_before_OFDM_gen_for_N_ID_2=%s.png'%N_ID_2)
</t>
<t tx="michael.20120312091134.1398"></t>
<t tx="michael.20120312091134.1399">def PSS_baseband_IQ_spectrum_correlation(to_draw=True):
    
    pss_iq_sig_list = [0]*3
    pss_baseband_IQ_FFT_list = [0] * 3
    corr_dict = dict()
    cs_list = arange(-1*(N/2), N/2, 1)
    max_dict = dict()
    
    for N_ID_2 in N_ID_2_tuple:
        
        pss_freq_symbol_array = pss_symbol_array(N_ID_2, N_DL_RB, N_RB_sc)
        pss_baseband_IQ = s_p_l(pss_freq_symbol_array, l, N_DL_RB, N_RB_sc, N_DL_CP, delta_f)[-1*N:]
        pss_baseband_IQ_FFT_list[N_ID_2] = fft.fft(pss_baseband_IQ, N)

    #print cs_corr.shape, cs_list.shape
    legend_list = list()
    y_offsets = dict()
    y_offsets[(0,0)] = -20
    y_offsets[(0,1)] = 10
    y_offsets[(0,2)] = 20
    y_offsets[(1,1)] = -35
    y_offsets[(1,2)] = 40
    y_offsets[(2,2)] = -50
    for p in N_ID_2_tuple:
        for q in N_ID_2_tuple:
            if p&lt;=q:
                corr_dict[(p,q)] = array( [0] *N )
                for i in arange(len(cs_list)):
                    corr_dict[(p,q)][i] = abs(correlate(pss_baseband_IQ_FFT_list[p], roll(pss_baseband_IQ_FFT_list[q],cs_list[i]))[0])
                max_dict[(p,q)] = find_max(corr_dict[(p,q)])
    # normalize the correlation results
    overall_max_y = 0
    for k in max_dict.keys():
        x, y = max_dict[k]
        if y&gt;overall_max_y:
            overall_max_y = y
    
    overall_max_y = float(overall_max_y)
    for k in max_dict.keys():
        x, y = max_dict[k]
        max_dict[k] = (x, y/overall_max_y)
    
    for k in corr_dict.keys():
        corr_dict[k] = corr_dict[k]/overall_max_y
    
    if to_draw:
        for p,q in corr_dict.keys():
            plt.plot(cs_list, corr_dict[(p,q)], marker='+', linestyle='-')
            legend_list.append( 'N_ID_2 %s vs. %s'%(p,q) )
            x, y = max_dict[(p,q)]
            plt.annotate('Max of N_ID_2 %svs%s =%4.4s @ cs=%s'%(p,q,y,cs_list[x]), xy=(cs_list[x], y), arrowprops=dict(facecolor='black', shrink=0.15), textcoords='offset points', xytext=(60, y_offsets[(p,q)]))
        plt.title('PSS baseband IQ spectrum correlation after OFDM generation')
        plt.legend(legend_list)
        plt.xlabel("Cyclic Shift")
        plt.ylabel("Correlation (normalized to peak)")
        plt.show()
    
    return corr_dict
    #plt.savefig('PSS_Uu_signal_inner_products.png', figsize=(1280,800), dpi=200, pad_inches=2)

</t>
<t tx="michael.20120312091134.1400">def PSS_received_IQ_time_domain_correlation(to_draw=True):
    
    pss_received_IQ_list = [0]*3
    pss_baseband_IQ_list = [0] * 3
    
    for N_ID_2 in N_ID_2_tuple:
        
        pss_freq_symbol_array = pss_symbol_array(N_ID_2, N_DL_RB, N_RB_sc)
        pss_baseband_IQ = s_p_l(pss_freq_symbol_array, l, N_DL_RB, N_RB_sc, N_DL_CP, delta_f)
        pss_baseband_IQ_list[N_ID_2] = pss_baseband_IQ[-1*N:]
        pss_uu_sig = downlink_modulate(pss_baseband_IQ, t, f_0)
        pss_received_IQ_list[N_ID_2] = downlink_downconvert(pss_uu_sig, t, f_0)[-1*N:]
    
    cs_corr = array([0]*N)
    cs_list = arange(-1*(N/2), N/2, 1)
    #print cs_corr.shape, cs_list.shape
    legend_list = list()
    y_offsets = dict()
    y_offsets[(0,0)] = -10
    y_offsets[(0,1)] = 10
    y_offsets[(0,2)] = 20
    y_offsets[(1,1)] = -10
    y_offsets[(1,2)] = 10
    y_offsets[(2,2)] = -30
    for p in N_ID_2_tuple:
        for q in N_ID_2_tuple:
            if p&lt;=q:
                for i in arange(len(cs_list)):
                    cs_corr[i] = abs(correlate(pss_baseband_IQ_list[p], roll(pss_received_IQ_list[q],cs_list[i]))[0])
                plt.plot(cs_list, cs_corr, marker='+', linestyle='-')
                legend_list.append( 'N_ID_2 %s vs. %s'%(p,q) )
                # add anotation to the max
                x, y = find_max(cs_corr)
                plt.annotate('Max of N_ID_2 %svs%s =%s @ cs=%s'%(p,q,y,cs_list[x]), xy=(cs_list[x], y), arrowprops=dict(facecolor='black', shrink=0.15), textcoords='offset points', xytext=(40, y_offsets[(p,q)]))
                
    plt.title('PSS received IQ correlation')
    plt.xlabel('Cyclic Shift')
    plt.ylabel('Correlation value')
    plt.legend(legend_list)
    plt.show()
    #plt.savefig('PSS_Uu_signal_inner_products.png', figsize=(1280,800), dpi=200, pad_inches=2)
</t>
<t tx="michael.20120312091134.1401">def PSS_Uu_signal_downconverted_correlation():
    for correlation_type in ('IQ', 'I+Q', 'I', 'Q'):
        PSS_Uu_signal_downconverted_correlation_IQ(correlation_type)

def PSS_Uu_signal_downconverted_correlation_IQ(correlation_type='I+Q', to_draw=True):
    
    pss_Uu_signal_downconverted_IQ_list = [0]*3
    pss_Uu_signal_downconverted_I_list = [0]*3
    pss_Uu_signal_downconverted_Q_list = [0]*3
    pss_baseband_IQ_list = [0]*3
    pss_baseband_I_list = [0]*3
    pss_baseband_Q_list = [0]*3
    
    for N_ID_2 in N_ID_2_tuple:
        pss_freq_symbol_array = pss_symbol_array(N_ID_2, N_DL_RB, N_RB_sc)
        pss_baseband_IQ = s_p_l(pss_freq_symbol_array, l, N_DL_RB, N_RB_sc, N_DL_CP, delta_f)
        pss_baseband_IQ_list[N_ID_2] = pss_baseband_IQ[-1*N:]
        pss_baseband_I_list[N_ID_2] = real(pss_baseband_IQ)[-1*N:]
        pss_baseband_Q_list[N_ID_2] = imag(pss_baseband_IQ)[-1*N:]
        pss_uu_sig = downlink_modulate(pss_baseband_IQ, t, f_0)
        pss_received_IQ = downlink_downconvert(pss_uu_sig, t, f_0)[-1*N:]
        pss_Uu_signal_downconverted_IQ_list[N_ID_2] = pss_received_IQ
        pss_Uu_signal_downconverted_I_list[N_ID_2] = real(pss_received_IQ)
        pss_Uu_signal_downconverted_Q_list[N_ID_2] = imag(pss_received_IQ)
    
    legend_list = list()
    corr_dict = dict()
    max_dict = dict()
    min_dict = dict()
    cs_list = arange(-1*(N/2), N/2, 1)
    #print cs_corr.shape, cs_list.shape
    legend_list = list()
    y_offsets = dict()
    y_offsets[(0,0)] = -20
    y_offsets[(0,1)] = 10
    y_offsets[(0,2)] = 20
    y_offsets[(1,1)] = -40
    y_offsets[(1,2)] = -80
    y_offsets[(2,2)] = -60
    for p in N_ID_2_tuple:
        for q in N_ID_2_tuple:
            if p&lt;=q:
                corr_dict[(p,q)] = array([0]*N)
                for i in arange(len(cs_list)):
                    if correlation_type=='I+Q':
                        corr_dict[(p,q)][i] = abs(correlate(pss_baseband_I_list[p], roll(pss_Uu_signal_downconverted_I_list[q],cs_list[i]))[0]) + abs(correlate(pss_baseband_Q_list[p], roll(pss_Uu_signal_downconverted_Q_list[q],cs_list[i]))[0])
                    elif correlation_type=='I':
                        corr_dict[(p,q)][i] = abs(correlate(pss_baseband_I_list[p], roll(pss_Uu_signal_downconverted_I_list[q],cs_list[i]))[0])
                    elif correlation_type=='Q':
                        corr_dict[(p,q)][i] = correlate(pss_baseband_Q_list[p], roll(pss_Uu_signal_downconverted_Q_list[q],cs_list[i]))[0]
                    elif correlation_type=='IQ':
                        corr_dict[(p,q)][i] = abs(correlate(pss_baseband_IQ_list[p], roll(conjugate(pss_Uu_signal_downconverted_IQ_list[q]),cs_list[i]))[0])
                max_dict[(p,q)] = find_max(corr_dict[(p,q)])
                min_dict[(p,q)] = find_min(corr_dict[(p,q)])
                
    overall_max_y = 0
    for k in max_dict.keys():
        x, y = max_dict[k]
        if y&gt;overall_max_y:
            overall_max_y = y
    for k in min_dict.keys():
        x, y = min_dict[k]
        if abs(y)&gt;overall_max_y:
            overall_max_y = abs(y)
    overall_max_y = float(overall_max_y)
    for k in max_dict.keys():
        x, y = max_dict[k]
        max_dict[k] = (x, y/overall_max_y)
    for k in min_dict.keys():
        x, y = min_dict[k]
        min_dict[k] = (x, y/overall_max_y)
    for k in corr_dict.keys():
        corr_dict[k] = corr_dict[k]/overall_max_y
    if to_draw:
        for p,q in corr_dict.keys():
            plt.plot(cs_list, corr_dict[(p,q)], marker='+', linestyle='-')
            legend_list.append( 'N_ID_2 %s vs. %s'%(p,q) )
            x, y = max_dict[(p,q)]
            plt.annotate('Max of N_ID_2 %svs%s =%4.4s @ cs=%s'%(p,q,y,cs_list[x]), xy=(cs_list[x], y), arrowprops=dict(facecolor='black', shrink=0.15), textcoords='offset points', xytext=(60, y_offsets[(p,q)]))
            if correlation_type=='Q':
                x, y = min_dict[(p,q)]
                plt.annotate('Min of N_ID_2 %svs%s =%4.4s @ cs=%s'%(p,q,y,cs_list[x]), xy=(cs_list[x], y), arrowprops=dict(facecolor='black', shrink=0.15), textcoords='offset points', xytext=(30, -1*y_offsets[(p,q)]))
                #print x,y
        plt.title('PSS Uu signal downconverted correlation, type: %s'%correlation_type)
        plt.legend(legend_list)
        plt.xlabel("Cyclic Shift")
        plt.ylabel("Correlation (normalized to peak)")
        plt.show()
    
    return corr_dict
</t>
<t tx="michael.20120312091134.1402">def PSS_baseband_detect(baseband_IQ_signal, local_t, to_draw=False):
    '''
    PSS_baseband_detect(baseband_IQ_signal, t): index
    return the index of the start of PSS in given baseband IQ signal sequence
    Note: for this function, the parameter t must be of the scale of second, and should not be decimated.
    '''
    baseband_IQ_signal_conj = conjugate(baseband_IQ_signal)
    baseband_IQ_signal_I = real(baseband_IQ_signal)
    baseband_IQ_signal_Q = imag(baseband_IQ_signal)
    
    pss_baseband_IQ_list = [0] * 3
    pss_baseband_I_list = [0]*3
    pss_baseband_Q_list = [0]*3
    
    tmp_t = arange(0, (N_CP_l+N)*T_s, T_s)
    N_ID_2_tuple = (0,1)
    for N_ID_2 in N_ID_2_tuple:
        
        pss_seq = pss_symbol_array(N_ID_2, N_DL_RB, N_RB_sc)
        pss_baseband_IQ = s_p_l(pss_seq, l, N_DL_RB, N_RB_sc, N_DL_CP, delta_f)
        pss_baseband_IQ_list[N_ID_2] = pss_baseband_IQ[-1*N:]
        pss_baseband_I_list[N_ID_2] = real(pss_baseband_IQ[-1*N:])
        pss_baseband_Q_list[N_ID_2] = imag(pss_baseband_IQ[-1*N:])
    
    legend_list = list()
    corr_list = [0]*3
    offset_list = arange(0, len(local_t)-N+1, 1)
    max_list = [0]*3
    for i in N_ID_2_tuple:
        corr_list[i] = array( [0.0] * len(offset_list) )
    
    legend_list = list()
    y_offsets = (-80, -80, -80)
    
    for offset in offset_list:
        for N_ID in N_ID_2_tuple:
            corr_list[N_ID][offset] = correlate(baseband_IQ_signal_Q[offset:offset+N], pss_baseband_Q_list[N_ID])[0]
            #corr_list[N_ID][offset] = abs(correlate(baseband_IQ_signal_conj[offset:offset+N], pss_baseband_IQ_list[N_ID])[0])
            #corr_list[N_ID][offset] = abs(correlate(baseband_IQ_signal_conj[offset:offset+N], baseband_IQ_signal[144:144+N])[0])
    n_ID_2, X, Y = -1, 0, 0
    for N_ID_2 in N_ID_2_tuple:
        x, y = find_max(corr_list[N_ID_2])
        if y&gt;abs(Y):
            n_ID_2, X, Y = N_ID_2, x, y
        x, y = find_min(corr_list[N_ID_2])
        if abs(y)&gt;abs(Y):
            n_ID_2, X, Y = N_ID_2, x, y
    Y = float(Y)
    for N_ID_2 in N_ID_2_tuple:
        corr_list[N_ID_2] = corr_list[N_ID_2]/abs(Y)
    Y = Y/abs(Y)
    if n_ID_2==1 and Y&lt;0:
        n_ID_2 = 2
                
    if to_draw:
        for N_ID_2 in N_ID_2_tuple:
            plt.plot(1000*local_t[:-1*(N-1)], corr_list[N_ID_2], marker='+', linestyle='-')
            legend_list.append( 'N_ID_2=%s'%N_ID_2 )
        plt.annotate('Highest peak with N_ID_2=%s: %4.4s @start_index=%s'%(n_ID_2,Y,X), xy=(1000*t[X], Y), arrowprops=dict(facecolor='black', shrink=0.15), textcoords='offset points', xytext=(-20, y_offsets[N_ID_2]))
        plt.title('PSS baseband detect')
        plt.legend(legend_list)
        plt.xlabel("t (ms)")
        plt.ylabel("Correlation")
        max_t = 1000*local_t[:-1*(N-1)][-1]
        min_t = 1000*local_t[0]
        plt.axis([min_t-max_t*0.01, min(1000*local_t[-1], max_t*1.3), -0.1*Y, 1.1*Y])
        plt.show()
    
    return (n_ID_2,X,Y)

def test_PSS_detect_in_baseband_IQ():
    
    for n_ID_2 in N_ID_2_tuple:

        pss_sequence = pss_symbol_array(n_ID_2, N_DL_RB, N_RB_sc)
        pss_baseband_IQ = s_p_l(pss_sequence, l, N_DL_RB, N_RB_sc, N_DL_CP, delta_f)
        pss_Uu_sig = downlink_modulate(pss_baseband_IQ, t, f_0)
        pss_received_IQ = downlink_downconvert(pss_Uu_sig, t, f_0)
        received_baseband_IQ = array( [0.0+0.0*1j] * len(pss_received_IQ) * 2 )
        received_baseband_IQ[:len(pss_received_IQ)] = pss_received_IQ
        long_t = arange(0, 2*(N_CP_l+N)*T_s, T_s)
        
        PSS_baseband_detect(received_baseband_IQ, long_t, to_draw=True)
        #PSS_baseband_detect(pss_received_IQ, t, to_draw=True)
</t>
<t tx="michael.20120312091134.1403"></t>
<t tx="michael.20120312091134.1404">def sss_x5(mask, n):
    x_init = 0b10000
    while n&gt;4:
        tmp = 0
        for i in (0,1,2,3,4):
            if (mask&gt;&gt;i)&amp;1 == 1: # feedback for this item is enabled
                tmp += int((x_init&gt;&gt;i)&amp;1)
            tmp = tmp%2
        x_init = x_init&gt;&gt;1 ^ tmp*(2**4)
        n -= 1
    return int((x_init&gt;&gt;n)&amp;1)


def sss_z_(i):
    if i &gt;=0 and i &lt;=30:
        return 1 - 2 * sss_x5(0b10111, i)

def sss_z_1(m, n):
    return sss_z_((n+(m%8))%31)

def sss_c_(i):
    if i&gt;=0 and i&lt;=30:
        return 1 - 2 * sss_x5(0b01001, i)

def sss_c_0(n, N_ID_2):
    return sss_c_((n+N_ID_2)%31)

def sss_c_1(n, N_ID_2):
    return sss_c_((n+N_ID_2+3)%31)

def sss_s_(i):
    return 1 - 2 * sss_x5(0b00101, i)

def sss_s(m, n):
    return sss_s_((n+m)%31)

def sss_d(n, subframe, N_ID_cell):
    N_ID_1 = N_ID_cell/3
    N_ID_2 = N_ID_cell%3
    q_ = N_ID_1/30
    q = (N_ID_1 + q_*(q_+1)/2)/30
    m_ = N_ID_1 + q*(q+1)/2
    m_0 = m_%31
    m_1 = (m_0 + m_/31 + 1)%31
    if n%2==0:
        n_ = n/2
        if subframe == 0:
            result = sss_s(m_0, n_) * sss_c_0(n_, N_ID_2)
        elif subframe == 5:
            result = sss_s(m_1, n_) * sss_c_0(n_, N_ID_2)
    else:
        n_ = (n-1)/2
        if subframe == 0:
            result = sss_s(m_1, n_) * sss_c_1(n_, N_ID_2) * sss_z_1(m_0, n_)
        elif subframe == 5:
            result = sss_s(m_0, n_) * sss_c_1(n_, N_ID_2) * sss_z_1(m_1, n_)
    return result

def sss_seq(subframe, N_ID_cell):
    sss = array([0] * 62)
    for i in range(62):
        sss[i] = sss_d(i, subframe, N_ID_cell)
    return sss
</t>
<t tx="michael.20120314211632.1426">def sss_baseband_IQ_correlation(to_draw=True):
    
    #sss_dict = SSS_sequence_generation()
    
    subframe = 0
    N_ID_cell = 0
    
    sss_re_array = sss_symbol_array(subframe, N_ID_cell, N_DL_RB, N_RB_sc)
    sss_baseband_IQ = s_p_l(sss_re_array, l, N_DL_RB, N_RB_sc, N_DL_CP, delta_f)[-1*N:]
    sss_baseband_IQ_conj = conjugate(sss_baseband_IQ)

    corr_dict = dict()
    cs_list = arange(-1*(N/2), N/2, 1)
    max_dict = dict()

    #print cs_corr.shape, cs_list.shape
    legend_list = list()
    y_offsets = dict()


    corr_dict[(subframe,N_ID_cell)] = array( [0] *N )
    for i in arange(len(cs_list)):
        corr_dict[(subframe,N_ID_cell)][i] = abs(correlate(sss_baseband_IQ, roll(sss_baseband_IQ_conj,cs_list[i]))[0])
    max_dict[(subframe,N_ID_cell)] = find_max(corr_dict[(subframe,N_ID_cell)])
    # normalize the correlation results
    overall_max_y = 0
    for k in max_dict.keys():
        x, y = max_dict[k]
        if y&gt;overall_max_y:
            overall_max_y = y
    overall_max_y = float(overall_max_y)
    for k in max_dict.keys():
        x, y = max_dict[k]
        max_dict[k] = (x, y/overall_max_y)
    for k in corr_dict.keys():
        corr_dict[k] = corr_dict[k]/overall_max_y
    
    if to_draw:
        for subframe,N_ID_cell in max_dict.keys():
            y_offsets[(subframe,N_ID_cell)] = -30
        for subframe,N_ID_cell in corr_dict.keys():
            plt.plot(cs_list, corr_dict[(subframe,N_ID_cell)], marker='+', linestyle='-')
            legend_list.append( 'subframe=%s, N_ID_cell=%s'%(subframe,N_ID_cell) )
            x, y = max_dict[(subframe,N_ID_cell)]
            plt.annotate('Max of subframe=%s, N_ID_cell=%s: %4.4s @ cs=%s'%(subframe,N_ID_cell,y,cs_list[x]), xy=(cs_list[x], y), arrowprops=dict(facecolor='black', shrink=0.15), textcoords='offset points', xytext=(60, y_offsets[(subframe,N_ID_cell)]))
        plt.title('SSS baseband IQ correlation')
        plt.legend(legend_list)
        plt.xlabel("Cyclic Shift")
        plt.ylabel("Correlation (normalized to peak)")
        plt.show()
    
    return corr_dict
    #plt.savefig('PSS_Uu_signal_inner_products.png', figsize=(1280,800), dpi=200, pad_inches=2)</t>
<t tx="michael.20120314211632.1427">def sss_baseband_IQ_spectrum_correlation_ref(ref_subframe, ref_N_ID_cell, to_draw=True):
    
    #sss_dict = SSS_sequence_generation()

    ref_sss_re_array = sss_symbol_array(ref_subframe, ref_N_ID_cell, N_DL_RB, N_RB_sc)
    ref_sss_baseband_IQ = s_p_l(ref_sss_re_array, l, N_DL_RB, N_RB_sc, N_DL_CP, delta_f)[-1*N:]
    ref_sss_baseband_IQ_fft = fft.fft(ref_sss_baseband_IQ, N)
    ref_sss_baseband_IQ_fft_conj = conjugate(ref_sss_baseband_IQ_fft)
    
    subframe_list = (0, 5)
    N_ID_cell_list = (0, 1, 2, 50, 167)
    sss_baseband_IQ_dict = dict()
    for subframe in subframe_list:
        for N_ID_cell in N_ID_cell_list:
            sss_re_array = sss_symbol_array(subframe, N_ID_cell, N_DL_RB, N_RB_sc)
            sss_baseband_IQ_dict[(subframe,N_ID_cell)] = s_p_l(sss_re_array, l, N_DL_RB, N_RB_sc, N_DL_CP, delta_f)[-1*N:]

    corr_dict = dict()
    cs_list = arange(-1*(N/2), N/2, 1)
    max_dict = dict()

    #print cs_corr.shape, cs_list.shape
    legend_list = list()
    y_offsets = dict()

    for subframe in subframe_list:
        for N_ID_cell in N_ID_cell_list:
            corr_dict[(subframe,N_ID_cell)] = array( [0] *N )
            for i in arange(len(cs_list)):
                corr_dict[(subframe,N_ID_cell)][i] = abs(correlate(ref_sss_baseband_IQ_fft_conj, fft.fft(roll(sss_baseband_IQ_dict[(subframe,N_ID_cell)],cs_list[i])))[0])
            max_dict[(subframe,N_ID_cell)] = find_max(corr_dict[(subframe,N_ID_cell)])
    # normalize the correlation results
    overall_max_y = 0
    for k in max_dict.keys():
        x, y = max_dict[k]
        if y&gt;overall_max_y:
            overall_max_y = y
    overall_max_y = float(overall_max_y)
    for k in max_dict.keys():
        x, y = max_dict[k]
        max_dict[k] = (x, y/overall_max_y)
    for k in corr_dict.keys():
        corr_dict[k] = corr_dict[k]/overall_max_y
    
    if to_draw:
        for subframe,N_ID_cell in max_dict.keys():
            y_offsets[(subframe,N_ID_cell)] = 60
        y_offsets[(ref_subframe,ref_N_ID_cell)] = -80
        for subframe,N_ID_cell in corr_dict.keys():
            plt.plot(cs_list, corr_dict[(subframe,N_ID_cell)], marker='+', linestyle='-')
            legend_list.append( 'subframe=%s, N_ID_cell=%s'%(subframe,N_ID_cell) )
            x, y = max_dict[(subframe,N_ID_cell)]
            plt.annotate('Max of subframe=%s, N_ID_cell=%s: %4.4s @ cs=%s'%(subframe,N_ID_cell,y,cs_list[x]), xy=(cs_list[x], y), arrowprops=dict(facecolor='black', shrink=0.15), textcoords='offset points', xytext=(-90, y_offsets[(subframe,N_ID_cell)]))
        plt.title('SSS baseband IQ correlation reference subframe=%s N_ID_cell=%s'%(ref_subframe,ref_N_ID_cell))
        plt.legend(legend_list)
        plt.xlabel("Cyclic Shift")
        plt.ylabel("Correlation (normalized to peak)")
        plt.show()
    
    return corr_dict

def sss_baseband_IQ_spectrum_correlation():
    for ref_subframe in (0, 5):
        for ref_N_ID_cell in (0,):
            sss_baseband_IQ_spectrum_correlation_ref(ref_subframe, ref_N_ID_cell, to_draw=True)</t>
<t tx="michael.20120314211632.1428">def SSS_signal_Uu_ref(ref_subframe, ref_N_ID_cell):
    
    sss_re_array = sss_symbol_array(ref_subframe, ref_N_ID_cell, N_DL_RB, N_RB_sc)
    sss_baseband_IQ = s_p_l(sss_re_array, l, N_DL_RB, N_RB_sc, N_DL_CP, delta_f)
    sss_Uu_signal = downlink_modulate(sss_baseband_IQ, t, f_0)
    
    legend_list = list()
    plt.plot(t*1000, sss_Uu_signal)
    legend_list.append('SSS Uu signal')
    plt.title('SSS Uu signal for subframe=%s N_ID_cell=%s'%(ref_subframe, ref_N_ID_cell))
    plt.xlabel('Time (ms)')
    plt.ylabel('Signal level')
    plt.legend(legend_list)
    #plt.axis( [-0.01, 0.075, -0.1, 14] )
    plt.show()
    #plt.savefig('PSS_signal_Uu_for_N_ID_2=%s.png'%N_ID_2, dpi=300)

def SSS_signal_Uu():
    SSS_signal_Uu_ref(0, 0)</t>
<t tx="michael.20120314211632.1429">def SSS_received_IQ_ref(ref_subframe, ref_N_ID_cell):
    
    sss_re_array = sss_symbol_array(ref_subframe, ref_N_ID_cell, N_DL_RB, N_RB_sc)
    sss_baseband_IQ = s_p_l(sss_re_array, l, N_DL_RB, N_RB_sc, N_DL_CP, delta_f)
    sss_Uu_signal = downlink_modulate(sss_baseband_IQ, t, f_0)
    sss_Uu_signal_downconverted = downlink_downconvert(sss_Uu_signal, t, f_0)
    
    legend_list = list()
    plt.plot(t*1000, sss_Uu_signal_downconverted)
    legend_list.append('SSS Uu signal downconverted')
    plt.title('SSS Uu signal downconverted for subframe=%s N_ID_cell=%s'%(ref_subframe, ref_N_ID_cell))
    plt.xlabel('Time (ms)')
    plt.ylabel('Signal level')
    plt.legend(legend_list)
    #plt.axis( [-0.01, 0.075, -0.1, 14] )
    plt.show()
    #plt.savefig('PSS_signal_Uu_for_N_ID_2=%s.png'%N_ID_2, dpi=300)

def SSS_received_IQ():
    SSS_received_IQ_ref(0, 0)</t>
<t tx="michael.20120314211632.1430">def SSS_received_IQ_spectrum_correlation_ref(ref_subframe, ref_N_ID_cell, to_draw=True):

    ref_sss_re_array = sss_symbol_array(ref_subframe, ref_N_ID_cell, N_DL_RB, N_RB_sc)
    ref_sss_baseband_IQ = s_p_l(ref_sss_re_array, l, N_DL_RB, N_RB_sc, N_DL_CP, delta_f)
    ref_sss_Uu_signal = downlink_modulate(ref_sss_baseband_IQ, t, f_0)
    ref_sss_received_IQ = downlink_downconvert(ref_sss_Uu_signal, t, f_0)
    
    ref_sss_baseband_IQ_fft = fft.fft(ref_sss_baseband_IQ[-1*N:], N)
    ref_sss_baseband_IQ_fft_conj = conjugate(ref_sss_baseband_IQ_fft)
    ref_sss_received_IQ_fft = fft.fft(ref_sss_received_IQ[-1*N:], N)
    ref_sss_received_IQ_fft_conj = conjugate(ref_sss_received_IQ_fft)
    
    # must we do coherent detection??
    channel_est = ref_sss_received_IQ_fft/ref_sss_baseband_IQ_fft
    est_ref_sss_received_IQ_fft_conj = conjugate(ref_sss_baseband_IQ_fft * channel_est)
    
    subframe_list = (0,5)
    N_ID_cell_list = (0,1,80,90,167)
    sss_received_IQ_dict = dict()
    for subframe in subframe_list:
        for N_ID_cell in N_ID_cell_list:
            sss_re_array = sss_symbol_array(subframe, N_ID_cell, N_DL_RB, N_RB_sc)
            sss_baseband_IQ = s_p_l(sss_re_array, l, N_DL_RB, N_RB_sc, N_DL_CP, delta_f)
            sss_Uu_signal = downlink_modulate(sss_baseband_IQ, t, f_0)
            sss_received_IQ = downlink_downconvert(sss_Uu_signal, t, f_0)
            sss_received_IQ_dict[(subframe,N_ID_cell)] = sss_received_IQ[-1*N:]

    corr_dict = dict()
    cs_list = arange(-1*(N/2), N/2, 1)
    max_dict = dict()

    #print cs_corr.shape, cs_list.shape
    legend_list = list()
    y_offsets = dict()

    for subframe in subframe_list:
        for N_ID_cell in N_ID_cell_list:
            corr_dict[(subframe,N_ID_cell)] = array( [0] *N )
            for i in arange(len(cs_list)):
                corr_dict[(subframe,N_ID_cell)][i] = abs(correlate(est_ref_sss_received_IQ_fft_conj, fft.fft(roll(sss_received_IQ_dict[(subframe,N_ID_cell)],cs_list[i]), N))[0])
            max_dict[(subframe,N_ID_cell)] = find_max(corr_dict[(subframe,N_ID_cell)])
    # normalize the correlation results
    overall_max_y = 0
    for k in max_dict.keys():
        x, y = max_dict[k]
        if y&gt;overall_max_y:
            overall_max_y = y
    overall_max_y = float(overall_max_y)
    for k in max_dict.keys():
        x, y = max_dict[k]
        max_dict[k] = (x, y/overall_max_y)
    for k in corr_dict.keys():
        corr_dict[k] = corr_dict[k]/overall_max_y
    
    if to_draw:
        for subframe,N_ID_cell in max_dict.keys():
            y_offsets[(subframe,N_ID_cell)] = 60
        y_offsets[(ref_subframe,ref_N_ID_cell)] = -80
        for subframe,N_ID_cell in corr_dict.keys():
            plt.plot(cs_list, corr_dict[(subframe,N_ID_cell)], marker='+', linestyle='-')
            legend_list.append( 'subframe=%s, N_ID_cell=%s'%(subframe,N_ID_cell) )
            x, y = max_dict[(subframe,N_ID_cell)]
            plt.annotate('Max of subframe=%s, N_ID_cell=%s: %4.4s @ cs=%s'%(subframe,N_ID_cell,y,cs_list[x]), xy=(cs_list[x], y), arrowprops=dict(facecolor='black', shrink=0.15), textcoords='offset points', xytext=(-90, y_offsets[(subframe,N_ID_cell)]))
        plt.title('SSS received IQ correlation reference subframe=%s N_ID_cell=%s'%(ref_subframe,ref_N_ID_cell))
        plt.legend(legend_list)
        plt.xlabel("Cyclic Shift")
        plt.ylabel("Correlation (normalized to peak)")
        plt.show()
    
    return corr_dict

def SSS_received_IQ_spectrum_correlation():
    for ref_subframe in (0,):
        for ref_N_ID_cell in (0,):
            SSS_received_IQ_spectrum_correlation_ref(ref_subframe, ref_N_ID_cell, to_draw=True)</t>
<t tx="michael.20120314211632.1431">def SSS_baseband_detect(baseband_IQ_signal, local_t, to_draw=False):
    '''
    SSS_baseband_detect(baseband_IQ_signal, t): index
    return the index of the start of SSS in given baseband IQ signal sequence
    Note: for this function, the parameter t must be of the scale of second, and should not be decimated.
    '''
    #baseband_IQ_signal_conj = conjugate(baseband_IQ_signal)
    #baseband_IQ_signal_I = real(baseband_IQ_signal)
    #baseband_IQ_signal_Q = imag(baseband_IQ_signal)
    
    ref_subframe_list = (0,5)
    ref_N_ID_cell_list = (0,1)
    
    sss_ref_fft_conj_dict = dict()
    for ref_subframe in ref_subframe_list:
        for ref_N_ID_cell in ref_N_ID_cell_list:
            ref_sss_re_array = sss_symbol_array(ref_subframe, ref_N_ID_cell, N_DL_RB, N_RB_sc)
            ref_sss_baseband_IQ = s_p_l(ref_sss_re_array, l, N_DL_RB, N_RB_sc, N_DL_CP, delta_f)
            ref_sss_Uu_signal = downlink_modulate(ref_sss_baseband_IQ, t, f_0)
            ref_sss_received_IQ = downlink_downconvert(ref_sss_Uu_signal, t, f_0)
            ref_sss_baseband_IQ_fft = fft.fft(ref_sss_baseband_IQ[-1*N:], N)
            ref_sss_baseband_IQ_fft_conj = conjugate(ref_sss_baseband_IQ_fft)
            ref_sss_received_IQ_fft = fft.fft(ref_sss_received_IQ[-1*N:], N)
            ref_sss_received_IQ_fft_conj = conjugate(ref_sss_received_IQ_fft)
            # must we do coherent detection??
            channel_est = ref_sss_received_IQ_fft/ref_sss_baseband_IQ_fft
            est_ref_sss_received_IQ_fft_conj = conjugate(ref_sss_baseband_IQ_fft * channel_est)
            sss_ref_fft_conj_dict[(ref_subframe,ref_N_ID_cell)] = est_ref_sss_received_IQ_fft_conj
    
    tmp_t = arange(0, (N_CP_l+N)*T_s, T_s)
    
    legend_list = list()
    corr_dict = dict()
    offset_list = arange(0, len(local_t)-N+1, 1)
    max_dict = dict()
    
    for subframe in ref_subframe_list:
        for N_ID_cell in ref_N_ID_cell_list:
            corr_dict[(subframe,N_ID_cell)] = array( [0.0] * len(offset_list) )
            for offset in offset_list:
                corr_dict[(subframe,N_ID_cell)][offset] = abs(correlate(fft.fft(baseband_IQ_signal[offset:offset+N],N), sss_ref_fft_conj_dict[(subframe,N_ID_cell)])[0])
            max_dict[(subframe,N_ID_cell)] = find_max(corr_dict[(subframe,N_ID_cell)])
            #corr_list[N_ID][offset] = abs(correlate(baseband_IQ_signal_conj[offset:offset+N], pss_baseband_IQ_list[N_ID])[0])
            #corr_list[N_ID][offset] = abs(correlate(baseband_IQ_signal_conj[offset:offset+N], baseband_IQ_signal[144:144+N])[0])
    sframe, n_ID_cell, X, Y = -1, -1, -1, -1
    for subframe,N_ID_cell in max_dict.keys():
        x, y = max_dict[(subframe,N_ID_cell)]
        if y&gt;Y:
            sframe, n_ID_cell, X, Y = subframe, N_ID_cell, x, y
    Y = float(Y)
    for subframe,N_ID_cell in max_dict.keys():
        corr_dict[(subframe,N_ID_cell)] = corr_dict[(subframe,N_ID_cell)]/abs(Y)
    #print Y
    Y = Y/abs(Y)
                
    if to_draw:
        for subframe,N_ID_cell in max_dict.keys():
            plt.plot(1000*local_t[:-1*(N-1)], corr_dict[(subframe,N_ID_cell)], marker='+', linestyle='-')
            legend_list.append( 'subframe=%s, N_ID_cell=%s'%(subframe,N_ID_cell) )
        plt.annotate('Highest peak with subframe=%s N_ID_cell=%s: %4.4s @start_index=%s'%(sframe,n_ID_cell,Y,X), xy=(1000*t[X], Y), arrowprops=dict(facecolor='black', shrink=0.15), textcoords='offset points', xytext=(-20, -30))
        plt.title('SSS baseband detect')
        plt.legend(legend_list)
        plt.xlabel("t (ms)")
        plt.ylabel("Correlation")
        max_t = 1000*local_t[:-1*(N-1)][-1]
        min_t = 1000*local_t[0]
        plt.axis([min_t-max_t*0.01, min(1000*local_t[-1], max_t*1.3), -0.1*Y, 1.1*Y])
        plt.show()
    
    return (sframe, n_ID_cell ,X, Y)

def test_SSS_detect_in_baseband_IQ():
    
    for subframe in (0,):
        for N_ID_cell in (0,):
            sss_re_array = sss_symbol_array(subframe, N_ID_cell, N_DL_RB, N_RB_sc)
            sss_baseband_IQ = s_p_l(sss_re_array, l, N_DL_RB, N_RB_sc, N_DL_CP, delta_f)
            sss_Uu_signal = downlink_modulate(sss_baseband_IQ, t, f_0)
            sss_received_IQ = downlink_downconvert(sss_Uu_signal, t, f_0)

        received_baseband_IQ = array( [0.0+0.0*1j] * len(sss_received_IQ) * 2 )
        received_baseband_IQ[:len(sss_received_IQ)] = sss_received_IQ
        long_t = arange(0, 2*(N_CP_l+N)*T_s, T_s)
        
        SSS_baseband_detect(received_baseband_IQ, long_t, to_draw=True)
</t>
</tnodes>
</leo_file>
